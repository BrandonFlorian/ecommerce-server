This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  config/
    stripe.ts
    supabase.ts
  controllers/
    auth.controller.ts
    cart.controller.ts
    order.controller.ts
    payment.controller.ts
    product.controller.ts
    shipping.controller.ts
    user.controller.ts
    webhook.controller.ts
  middlewares/
    auth.middleware.ts
    errorHandler.ts
  routes/
    admin.routes.ts
    auth.routes.ts
    cart.routes.ts
    order.routes.ts
    payment.routes.ts
    product.routes.ts
    shipping.routes.ts
    user.routes.ts
  services/
    auth.service.ts
    cart.service.ts
    order.service.ts
    payment.service.ts
    product.service.ts
    shipping.service.ts
    user.service.ts
  types/
    api.ts
    database.types.ts
  utils/
    validators/
      auth.validator.ts
      cart.validator.ts
      order.validator.ts
      payment.validator.ts
      product.validator.ts
      shipping.validator.ts
      user.validator.ts
    appError.ts
    logger.ts
    query-helper.ts
  app.ts
  server.ts
supabase/
  .gitignore
  config.toml
.env.example
.gitignore
db.sql
package.json
postman-collection.json
readme.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/config/stripe.ts">
import Stripe from "stripe";
import { logger } from "../utils/logger";

// Ensure required environment variables are set
if (!process.env.STRIPE_SECRET_KEY) {
  logger.error("Missing Stripe environment variables");
  process.exit(1);
}

// Create a Stripe instance
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2025-02-24.acacia",
  typescript: true,
});

export default stripe;
</file>

<file path="src/config/supabase.ts">
import { createClient } from "@supabase/supabase-js";

import { logger } from "../utils/logger";
import { Database } from "@/types/database.types";

// Ensure required environment variables are set
if (!process.env.SUPABASE_URL || !process.env.SUPABASE_ANON_KEY) {
  logger.error("Missing Supabase environment variables");
  process.exit(1);
}

// Create a Supabase client with the anonymous key for client-side operations
export const supabaseClient = createClient<Database>(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
);

// Create a Supabase admin client with service role key for admin operations
// This should only be used server-side for operations requiring admin privileges
export const supabaseAdmin = process.env.SUPABASE_SERVICE_ROLE_KEY
  ? createClient<Database>(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    )
  : null;

// Function to get admin client or throw if not available
export function getAdminClient() {
  if (!supabaseAdmin) {
    throw new Error(
      "Supabase admin client not available. Missing SUPABASE_SERVICE_ROLE_KEY."
    );
  }
  return supabaseAdmin;
}

// Export a function that creates a client with user's JWT for RLS policies
export const createUserClient = (jwt: string) => {
  return createClient<Database>(
    process.env.SUPABASE_URL as string,
    process.env.SUPABASE_ANON_KEY as string,
    {
      global: {
        headers: {
          Authorization: `Bearer ${jwt}`,
        },
      },
    }
  );
};
</file>

<file path="src/controllers/auth.controller.ts">
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
import {
  registerUser,
  loginUser,
  forgotPassword,
  resetPassword,
  RegisterUserDto,
  LoginUserDto,
} from "../services/auth.service";
import { AppError } from "../utils/appError";

// Register a new user
export const register = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400, errors.array()));
    }

    const userData: RegisterUserDto = {
      email: req.body.email,
      password: req.body.password,
      first_name: req.body.first_name,
      last_name: req.body.last_name,
      phone: req.body.phone,
    };

    const result = await registerUser(userData);

    res.status(201).json({
      status: "success",
      data: {
        user: {
          id: result.user.id,
          email: result.user.email,
          first_name: result.user.first_name,
          last_name: result.user.last_name,
          role: result.user.role,
        },
        token: result.token,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Login a user
export const login = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const loginData: LoginUserDto = {
      email: req.body.email,
      password: req.body.password,
    };

    const result = await loginUser(loginData);

    res.status(200).json({
      status: "success",
      data: {
        user: {
          id: result.user.id,
          email: result.user.email,
          first_name: result.user.first_name,
          last_name: result.user.last_name,
          role: result.user.role,
        },
        token: result.token,
      },
    });
  } catch (error) {
    next(error);
  }
};

// Request password reset
export const forgotPasswordController = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    await forgotPassword(req.body.email);

    res.status(200).json({
      status: "success",
      message: "Password reset instructions sent to your email",
    });
  } catch (error) {
    next(error);
  }
};

// Reset password
export const resetPasswordController = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const { token, password } = req.body;

    await resetPassword(token, password);

    res.status(200).json({
      status: "success",
      message: "Password has been reset successfully",
    });
  } catch (error) {
    next(error);
  }
};

// Get current user profile
export const getCurrentUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // User is already attached to req object by the protect middleware
    res.status(200).json({
      status: "success",
      data: {
        user: req.user,
      },
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/controllers/cart.controller.ts">
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
import {
  getOrCreateCart,
  addItemToCart,
  updateCartItem,
  removeCartItem,
  getCartWithItems,
  clearCart,
  CartItemDto,
} from "../services/cart.service";
import { AppError } from "../utils/appError";

// Get cart with all items
export const getCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get cart ID from session or user
    const userId = req.userId;
    const sessionId = req.cookies?.cartSessionId || req.body.sessionId;

    // Get or create cart
    const {
      cart,
      isNew,
      sessionId: newSessionId,
    } = await getOrCreateCart(userId, sessionId);

    // If this is a new session cart, set cookie
    if (isNew && newSessionId && !userId) {
      res.cookie("cartSessionId", newSessionId, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
      });
    }

    // Get cart with items
    const cartWithItems = await getCartWithItems(cart.id);

    res.status(200).json({
      status: "success",
      data: cartWithItems,
    });
  } catch (error) {
    next(error);
  }
};

// Add item to cart
export const addToCart = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    // Get cart ID from session or user
    const userId = req.userId;
    const sessionId = req.cookies?.cartSessionId || req.body.sessionId;

    // Get or create cart
    const {
      cart,
      isNew,
      sessionId: newSessionId,
    } = await getOrCreateCart(userId, sessionId);

    // If this is a new session cart, set cookie
    if (isNew && newSessionId && !userId) {
      res.cookie("cartSessionId", newSessionId, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
      });
    }

    // Add item to cart
    const itemData: CartItemDto = {
      product_id: req.body.product_id,
      quantity: req.body.quantity,
    };

    // Pass the session ID to the service function
    await addItemToCart(cart.id, itemData, newSessionId || sessionId);

    // Get updated cart with items
    const updatedCart = await getCartWithItems(
      cart.id,
      newSessionId || sessionId
    );

    res.status(200).json({
      status: "success",
      data: updatedCart,
    });
  } catch (error) {
    next(error);
  }
};

// Update cart item
export const updateItem = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    // Get cart ID from session or user
    const userId = req.userId;
    const sessionId = req.cookies?.cartSessionId || req.body.sessionId;

    // Get cart (must exist)
    const { cart } = await getOrCreateCart(userId, sessionId);

    // Update cart item
    await updateCartItem(cart.id, req.params.itemId, req.body.quantity);

    // Get updated cart with items
    const updatedCart = await getCartWithItems(cart.id);

    res.status(200).json({
      status: "success",
      data: updatedCart,
    });
  } catch (error) {
    next(error);
  }
};

// Remove an item from the cart
export const removeItem = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    console.log("Removing item from cart:", req.params.itemId);

    // Get cart ID from session or user
    const userId = req.userId;
    const sessionId = req.cookies?.cartSessionId || req.body.sessionId;

    // Get cart (must exist)
    const { cart } = await getOrCreateCart(userId, sessionId);

    // Remove cart item
    await removeCartItem(cart.id, req.params.itemId, sessionId);

    // Get updated cart with items
    const updatedCart = await getCartWithItems(cart.id, sessionId);

    res.status(200).json({
      status: "success",
      data: updatedCart,
    });
  } catch (error) {
    next(error);
  }
};

// Clear all items from the cart
export const clearCartItems = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Get cart ID from session or user
    const userId = req.userId;
    const sessionId = req.cookies?.cartSessionId || req.body.sessionId;

    // Get cart (must exist)
    const { cart } = await getOrCreateCart(userId, sessionId);

    // Clear the cart
    await clearCart(cart.id);

    // Get updated empty cart
    const updatedCart = await getCartWithItems(cart.id);

    res.status(200).json({
      status: "success",
      data: updatedCart,
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/controllers/order.controller.ts">
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
import {
  getUserOrders,
  getOrderById,
  cancelOrder,
  updateOrderStatus,
  getAllOrders,
  OrderPaginationParams,
} from "../services/order.service";
import { AppError } from "../utils/appError";

// Get all orders for the current user
export const getMyOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.userId!;

    const params: OrderPaginationParams = {
      page: req.query.page ? parseInt(req.query.page as string) : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      status: req.query.status as string,
      sort_by: req.query.sort_by as string,
      sort_order: req.query.sort_order as "asc" | "desc",
      start_date: req.query.start_date as string,
      end_date: req.query.end_date as string,
    };

    const result = await getUserOrders(userId, params);

    res.status(200).json({
      status: "success",
      pagination: result.pagination,
      data: result.orders,
    });
  } catch (error) {
    next(error);
  }
};

// Get a single order by ID
export const getOrderDetails = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.userId!;
    const orderId = req.params.id;

    const order = await getOrderById(orderId, userId);

    res.status(200).json({
      status: "success",
      data: order,
    });
  } catch (error) {
    next(error);
  }
};

// Cancel an order
export const cancelMyOrder = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.userId!;
    const orderId = req.params.id;

    const result = await cancelOrder(orderId, userId);

    res.status(200).json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

// Get all orders (admin only)
export const adminGetAllOrders = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const params: OrderPaginationParams = {
      page: req.query.page ? parseInt(req.query.page as string) : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      status: req.query.status as string,
      sort_by: req.query.sort_by as string,
      sort_order: req.query.sort_order as "asc" | "desc",
      start_date: req.query.start_date as string,
      end_date: req.query.end_date as string,
    };

    const result = await getAllOrders(params);

    res.status(200).json({
      status: "success",
      pagination: result.pagination,
      data: result.orders,
    });
  } catch (error) {
    next(error);
  }
};

// Get order details (admin)
export const adminGetOrderDetails = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const orderId = req.params.id;

    const order = await getOrderById(orderId);

    res.status(200).json({
      status: "success",
      data: order,
    });
  } catch (error) {
    next(error);
  }
};

// Update order status (admin only)
export const adminUpdateOrderStatus = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const orderId = req.params.id;
    const { status, tracking_number } = req.body;

    const result = await updateOrderStatus(orderId, status, tracking_number);

    res.status(200).json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/controllers/payment.controller.ts">
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
import {
  createPaymentIntent,
  confirmPaymentIntent,
  handleStripeWebhook,
  CreatePaymentIntentDto,
} from "../services/payment.service";
import { AppError } from "../utils/appError";
import stripe from "../config/stripe";

// Create a payment intent for checkout
export const createCheckoutSession = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const paymentData: CreatePaymentIntentDto = {
      cartId: req.body.cart_id,
      shipping_address_id: req.body.shipping_address_id,
      billing_address_id: req.body.billing_address_id,
      shipping_method: req.body.shipping_method,
      customerId: req.body.customer_id,
      metadata: req.body.metadata,
    };

    const result = await createPaymentIntent(paymentData);

    res.status(200).json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

// Check payment status
export const checkPaymentStatus = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { paymentIntentId } = req.params;

    const result = await confirmPaymentIntent(paymentIntentId);

    res.status(200).json({
      status: "success",
      data: result,
    });
  } catch (error) {
    next(error);
  }
};

// Handle Stripe webhook
export const stripeWebhook = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const signature = req.headers["stripe-signature"] as string;

    if (!signature) {
      console.log("No signature found");
      return res.status(400).json({ error: "Stripe signature missing" });
    }

    let event;

    try {
      // req.body is now a Buffer
      event = stripe.webhooks.constructEvent(
        req.body,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET as string
      );
    } catch (err: any) {
      console.log("Webhook signature verification failed:", err.message);
      return res.status(400).json({ error: err.message });
    }

    console.log("Webhook verified successfully:", event.type);

    const result = await handleStripeWebhook(event);

    res.status(200).json(result);
  } catch (error) {
    console.error("Webhook error:", error);
    // Always respond with a 200 to Stripe
    res.status(200).json({ received: true, error: true });
  }
};
</file>

<file path="src/controllers/product.controller.ts">
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
import {
  getProducts,
  getProductById,
  createProduct,
  updateProduct,
  deleteProduct,
  getProductsByCategory,
  searchProducts,
  getCategories,
  getCategoryById,
  ProductDto,
  PaginationParams,
} from "../services/product.service";
import { AppError } from "../utils/appError";

// Get all products with pagination and filtering
export const getAllProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const params: PaginationParams = {
      page: req.query.page ? parseInt(req.query.page as string) : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      sort_by: req.query.sort_by as string,
      sort_order: req.query.sort_order as "asc" | "desc",
      min_price: req.query.min_price
        ? parseFloat(req.query.min_price as string)
        : undefined,
      max_price: req.query.max_price
        ? parseFloat(req.query.max_price as string)
        : undefined,
      in_stock: req.query.in_stock === "true",
    };

    const result = await getProducts(params);

    res.status(200).json({
      status: "success",
      pagination: result.pagination,
      data: result.products,
    });
  } catch (error) {
    next(error);
  }
};

// Get a single product by ID
export const getProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const product = await getProductById(req.params.id);

    res.status(200).json({
      status: "success",
      data: product,
    });
  } catch (error) {
    next(error);
  }
};

// Create a new product (admin only)
export const createNewProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const productData: ProductDto = req.body;
    const product = await createProduct(productData);

    res.status(201).json({
      status: "success",
      data: product,
    });
  } catch (error) {
    next(error);
  }
};

// Update an existing product (admin only)
export const updateExistingProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const productData: Partial<ProductDto> = req.body;
    const product = await updateProduct(req.params.id, productData);

    res.status(200).json({
      status: "success",
      data: product,
    });
  } catch (error) {
    next(error);
  }
};

// Delete a product (admin only)
export const removeProduct = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await deleteProduct(req.params.id);

    res.status(204).json({
      status: "success",
      data: null,
    });
  } catch (error) {
    next(error);
  }
};

// Search products
export const searchAllProducts = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const query = req.query.q as string;

    if (!query) {
      return next(new AppError("Search query is required", 400));
    }

    const params: PaginationParams = {
      page: req.query.page ? parseInt(req.query.page as string) : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      sort_by: req.query.sort_by as string,
      sort_order: req.query.sort_order as "asc" | "desc",
      min_price: req.query.min_price
        ? parseFloat(req.query.min_price as string)
        : undefined,
      max_price: req.query.max_price
        ? parseFloat(req.query.max_price as string)
        : undefined,
      in_stock: req.query.in_stock === "true",
    };

    const result = await searchProducts(query, params);

    res.status(200).json({
      status: "success",
      pagination: result.pagination,
      data: result.products,
    });
  } catch (error) {
    next(error);
  }
};

// Get all product categories
export const getAllCategories = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const categories = await getCategories();

    res.status(200).json({
      status: "success",
      data: categories,
    });
  } catch (error) {
    next(error);
  }
};

// Get a single category by ID
export const getCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const category = await getCategoryById(req.params.id);

    res.status(200).json({
      status: "success",
      data: category,
    });
  } catch (error) {
    next(error);
  }
};

// Get products by category
export const getProductsInCategory = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const categoryId = req.params.id;

    const params: PaginationParams = {
      page: req.query.page ? parseInt(req.query.page as string) : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      sort_by: req.query.sort_by as string,
      sort_order: req.query.sort_order as "asc" | "desc",
      min_price: req.query.min_price
        ? parseFloat(req.query.min_price as string)
        : undefined,
      max_price: req.query.max_price
        ? parseFloat(req.query.max_price as string)
        : undefined,
      in_stock: req.query.in_stock === "true",
    };

    const result = await getProductsByCategory(categoryId, params);

    res.status(200).json({
      status: "success",
      pagination: result.pagination,
      data: result.products,
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/controllers/shipping.controller.ts">
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
import {
  calculateShippingRates,
  validateAddress,
  trackShipment,
  ShippingRateRequest,
  ShippingAddress,
} from "../services/shipping.service";
import { AppError } from "../utils/appError";
import { supabaseClient } from "../config/supabase";
import { logger } from "../utils/logger";

// Calculate shipping rates for cart items
export const getShippingRates = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    // Get the shipping address
    const addressId = req.body.address_id;
    const { data: address, error: addressError } = await supabaseClient
      .from("addresses")
      .select("*")
      .eq("id", addressId)
      .single();

    if (addressError || !address) {
      logger.error("Error retrieving shipping address:", addressError);
      return next(new AppError("Shipping address not found", 404));
    }

    // Get the cart items
    const cartId = req.body.cart_id;
    const { data: cartItems, error: cartError } = await supabaseClient
      .from("cart_items")
      .select(
        `
        id, 
        quantity,
        products:product_id (
          id, 
          weight, 
          dimensions
        )
      `
      )
      .eq("cart_id", cartId);

    if (cartError) {
      logger.error("Error retrieving cart items:", cartError);
      return next(new AppError("Failed to retrieve cart items", 500));
    }

    if (!cartItems || cartItems.length === 0) {
      return next(new AppError("Cart is empty", 400));
    }

    // Prepare the shipping rate request
    const rateRequest: ShippingRateRequest = {
      address: {
        address_line1: address.address_line1,
        address_line2: address.address_line2,
        city: address.city,
        state: address.state,
        postal_code: address.postal_code,
        country: address.country,
      },
      items: cartItems.map((item) => {
        // Use this pattern for accessing the product
        const product = Array.isArray(item.products)
          ? item.products[0]
          : item.products;

        return {
          product_id: product.id,
          quantity: item.quantity,
          weight: product.weight,
          dimensions: product.dimensions as {
            length: number;
            width: number;
            height: number;
          },
        };
      }),
    };

    // Calculate shipping rates
    const rates = await calculateShippingRates(rateRequest);

    res.status(200).json({
      status: "success",
      data: rates,
    });
  } catch (error) {
    next(error);
  }
};

// Validate a shipping address
export const validateShippingAddress = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const address: ShippingAddress = {
      address_line1: req.body.address_line1,
      address_line2: req.body.address_line2,
      city: req.body.city,
      state: req.body.state,
      postal_code: req.body.postal_code,
      country: req.body.country,
    };

    const addressValidationResult = await validateAddress(address);

    res.status(200).json({
      status: "success",
      data: addressValidationResult,
    });
  } catch (error) {
    next(error);
  }
};

// Track a shipment
export const trackOrder = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { trackingNumber } = req.params;

    if (!trackingNumber) {
      return next(new AppError("Tracking number is required", 400));
    }

    const trackingInfo = await trackShipment(trackingNumber);

    res.status(200).json({
      status: "success",
      data: trackingInfo,
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/controllers/user.controller.ts">
import { Request, Response, NextFunction } from "express";
import { validationResult } from "express-validator";
import {
  getUserProfile,
  updateUserProfile,
  getUserAddresses,
  addUserAddress,
  updateUserAddress,
  deleteUserAddress,
  getAllUsers,
  getUserDetails,
  UserProfileDto,
  AddressDto,
} from "../services/user.service";
import { AppError } from "../utils/appError";

// Get current user profile
export const getProfile = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.userId!;

    const user = await getUserProfile(userId);

    res.status(200).json({
      status: "success",
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

// Update current user profile
export const updateProfile = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const userId = req.userId!;
    const profileData: UserProfileDto = {
      first_name: req.body.first_name,
      last_name: req.body.last_name,
      phone: req.body.phone,
    };

    const user = await updateUserProfile(userId, profileData);

    res.status(200).json({
      status: "success",
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

// Get user addresses
export const getAddresses = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.userId!;

    const addresses = await getUserAddresses(userId);

    res.status(200).json({
      status: "success",
      data: addresses,
    });
  } catch (error) {
    next(error);
  }
};

// Add a new address
export const addAddress = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const userId = req.userId!;
    const addressData: AddressDto = {
      name: req.body.name,
      address_line1: req.body.address_line1,
      address_line2: req.body.address_line2,
      city: req.body.city,
      state: req.body.state,
      postal_code: req.body.postal_code,
      country: req.body.country,
      is_default: req.body.is_default,
    };

    const address = await addUserAddress(userId, addressData);

    res.status(201).json({
      status: "success",
      data: address,
    });
  } catch (error) {
    next(error);
  }
};

// Update an address
export const updateAddress = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return next(new AppError("Validation error", 400));
    }

    const userId = req.userId!;
    const addressId = req.params.id;
    const addressData: Partial<AddressDto> = req.body;

    const address = await updateUserAddress(userId, addressId, addressData);

    res.status(200).json({
      status: "success",
      data: address,
    });
  } catch (error) {
    next(error);
  }
};

// Delete an address
export const removeAddress = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.userId!;
    const addressId = req.params.id;

    await deleteUserAddress(userId, addressId);

    res.status(204).send();
  } catch (error) {
    next(error);
  }
};

// Admin: Get all users
export const adminGetAllUsers = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const page = req.query.page ? parseInt(req.query.page as string) : 1;
    const limit = req.query.limit ? parseInt(req.query.limit as string) : 20;

    const result = await getAllUsers(page, limit);

    res.status(200).json({
      status: "success",
      pagination: result.pagination,
      data: result.users,
    });
  } catch (error) {
    next(error);
  }
};

// Admin: Get user details
export const adminGetUserDetails = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.params.id;

    const user = await getUserDetails(userId);

    res.status(200).json({
      status: "success",
      data: user,
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/controllers/webhook.controller.ts">
import { Request, Response } from "express";
import stripe from "../config/stripe";
import { handleStripeWebhook } from "../services/payment.service";
import { logger } from "../utils/logger";

export const handleStripeWebhookRequest = (
  req: Request,
  res: Response
): void => {
  try {
    const signature = req.headers["stripe-signature"] as string;

    if (!signature) {
      logger.error("No Stripe signature found in webhook request");
      res.status(400).json({ error: "Stripe signature missing" });
      return;
    }

    // Verify the event
    let event;
    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET as string
      );
    } catch (err: any) {
      logger.error(`Webhook signature verification failed: ${err.message}`);
      res.status(400).json({ error: `Webhook Error: ${err.message}` });
      return;
    }

    logger.info(`Webhook received: ${event.type}`);

    // Process the event asynchronously but don't await it
    // This allows us to return a 200 response quickly
    handleStripeWebhook(event)
      .then(() => {
        logger.info(`Webhook processed successfully: ${event.type}`);
      })
      .catch((error) => {
        logger.error(`Error processing webhook: ${error.message}`);
      });

    // Return a 200 response immediately
    res.status(200).json({ received: true });
  } catch (error) {
    logger.error("Unexpected error in webhook handler:", error);
    // Always return 200 to Stripe to prevent retries
    res.status(200).json({ received: true, unexpectedError: true });
  }
};
</file>

<file path="src/middlewares/auth.middleware.ts">
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";
import { AppError } from "../utils/appError";
import { supabaseClient } from "../config/supabase";
import { logger } from "../utils/logger";

// Extend the Express Request interface to include user information
declare global {
  namespace Express {
    interface Request {
      user?: any;
      userId?: string;
      userRole?: string;
    }
  }
}

// Middleware to protect routes - requires valid JWT
export const protect = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    let token: string | undefined;

    // Get token from Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
    }

    // Also check for token in cookies (for browser clients)
    else if (req.cookies && req.cookies.authToken) {
      token = req.cookies.authToken;
    }

    // Check if token exists
    if (!token) {
      return next(
        new AppError("You are not logged in. Please log in to get access.", 401)
      );
    }

    // Verify token
    try {
      const decoded = jwt.verify(
        token,
        process.env.JWT_SECRET as string
      ) as any;

      // Check if the user still exists
      const { data: user, error } = await supabaseClient
        .from("users")
        .select("id, email, role")
        .eq("id", decoded.id)
        .single();

      if (error || !user) {
        return next(
          new AppError(
            "The user belonging to this token no longer exists.",
            401
          )
        );
      }

      // Add user info to request object
      req.user = user;
      req.userId = user.id;
      req.userRole = user.role;

      next();
    } catch (error) {
      return next(
        new AppError(
          "Invalid token or token has expired. Please log in again.",
          401
        )
      );
    }
  } catch (error) {
    logger.error("Error in auth middleware:", error);
    return next(new AppError("Authentication failed", 500));
  }
};

// Optional authentication middleware
export const optionalAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    let token: string | undefined;

    // Get token from Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
    }
    // Also check for token in cookies
    else if (req.cookies && req.cookies.authToken) {
      token = req.cookies.authToken;
    }

    if (token) {
      try {
        const decoded = jwt.verify(
          token,
          process.env.JWT_SECRET as string
        ) as any;

        // Check if the user exists
        const { data: user, error } = await supabaseClient
          .from("users")
          .select("id, email, role")
          .eq("id", decoded.id)
          .single();

        if (!error && user) {
          // Add user info to request object
          req.user = user;
          req.userId = user.id;
          req.userRole = user.role;
        }
      } catch (error) {
        // Don't return error, just continue without auth
        console.log("Token verification failed, continuing as anonymous");
      }
    }
    next();
  } catch (error) {
    next();
  }
};

// Middleware to restrict access to certain roles
export const restrictTo = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.userRole || !roles.includes(req.userRole)) {
      return next(
        new AppError("You do not have permission to perform this action", 403)
      );
    }
    next();
  };
};
</file>

<file path="src/middlewares/errorHandler.ts">
import { Request, Response, NextFunction } from "express";
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";
import { ValidationError } from "express-validator";

interface ApiValidationError extends AppError {
  errors?: ValidationError[];
}

// Central error handler middleware
export const errorHandler = (
  err: Error | AppError | ApiValidationError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Default values
  let statusCode = 500;
  let status = "error";
  let message = "Something went wrong";
  let errors: any = undefined;
  let stack: string | undefined = undefined;

  // If it's our operational error, use its values
  if ("statusCode" in err) {
    statusCode = err.statusCode;
    status = err.status || "error";
    message = err.message;
    if ("errors" in err && err.errors) {
      errors = err.errors;
    }
  } else {
    // For non-operational errors, keep a generic message to the client
    // but log the real error
    message = "Something went wrong";
    logger.error(err.message, { stack: err.stack });
  }

  // Only include stack trace in development
  if (process.env.NODE_ENV === "development") {
    stack = err.stack;
  }

  // Handle specific error types

  // Mongoose validation error
  if (err.name === "ValidationError") {
    statusCode = 400;
    status = "fail";
    // Handle mongoose validation errors here if you use mongoose
  }

  // JWT errors
  if (err.name === "JsonWebTokenError") {
    statusCode = 401;
    status = "fail";
    message = "Invalid token. Please log in again.";
  }

  if (err.name === "TokenExpiredError") {
    statusCode = 401;
    status = "fail";
    message = "Your token has expired. Please log in again.";
  }

  // Stripe errors
  if (err.name === "StripeError") {
    statusCode = 400;
    status = "fail";
    message = err.message;
  }

  // Database errors
  if (err.name === "PostgresError" || err.name === "SupabaseError") {
    statusCode = 500;
    status = "error";
    message = "Database error occurred";
  }

  // Send response
  res.status(statusCode).json({
    status,
    message,
    ...(errors && { errors }),
    ...(stack && { stack }),
    ...(process.env.NODE_ENV === "development" && { detail: err.message }),
  });
};
</file>

<file path="src/routes/admin.routes.ts">
import express from "express";
import { protect, restrictTo } from "../middlewares/auth.middleware";
import {
  adminGetAllOrders,
  adminGetOrderDetails,
  adminUpdateOrderStatus,
} from "../controllers/order.controller";
import {
  adminGetAllUsers,
  adminGetUserDetails,
} from "../controllers/user.controller";
import { updateOrderStatusValidator } from "../utils/validators/order.validator";

const router = express.Router();

// Protected routes for admins only
router.use(protect);
router.use(restrictTo("admin"));

// Dashboard stats route
router.get("/dashboard", (req, res) => {
  // This would be implemented with stats about orders, users, revenue, etc.
  res.status(200).json({
    status: "success",
    data: {
      message: "Admin dashboard stats will be implemented here",
    },
  });
});

// Order management routes
router.get("/orders", adminGetAllOrders);
router.get("/orders/:id", adminGetOrderDetails);
router.put("/orders/:id", updateOrderStatusValidator, adminUpdateOrderStatus);

// User management routes
router.get("/users", adminGetAllUsers);
router.get("/users/:id", adminGetUserDetails);

export default router;
</file>

<file path="src/routes/auth.routes.ts">
import express from "express";
import {
  register,
  login,
  forgotPasswordController,
  resetPasswordController,
  getCurrentUser,
} from "../controllers/auth.controller";
import {
  registerValidator,
  loginValidator,
  forgotPasswordValidator,
  resetPasswordValidator,
} from "../utils/validators/auth.validator";
import { protect } from "../middlewares/auth.middleware";

const router = express.Router();

// Public routes
router.post("/register", registerValidator, register);
router.post("/login", loginValidator, login);
router.post(
  "/forgot-password",
  forgotPasswordValidator,
  forgotPasswordController
);
router.post("/reset-password", resetPasswordValidator, resetPasswordController);

// Protected routes
router.get("/me", protect, getCurrentUser);

export default router;
</file>

<file path="src/routes/cart.routes.ts">
import express from "express";
import {
  getCart,
  addToCart,
  updateItem,
  removeItem,
  clearCartItems,
} from "../controllers/cart.controller";
import {
  addToCartValidator,
  updateCartItemValidator,
} from "../utils/validators/cart.validator";
import { optionalAuth } from "../middlewares/auth.middleware";

const router = express.Router();

// These routes work with or without authentication
// If authenticated, cart is tied to user
// If not, cart is tied to session cookie

router.get("/", optionalAuth, getCart);
router.post("/items", optionalAuth, addToCartValidator, addToCart);
router.put("/items/:itemId", optionalAuth, updateCartItemValidator, updateItem);
router.delete("/items/:itemId", optionalAuth, removeItem);
router.delete("/", optionalAuth, clearCartItems);

export default router;
</file>

<file path="src/routes/order.routes.ts">
import express from "express";
import {
  getMyOrders,
  getOrderDetails,
  cancelMyOrder,
  adminGetAllOrders,
  adminGetOrderDetails,
  adminUpdateOrderStatus,
} from "../controllers/order.controller";
import { updateOrderStatusValidator } from "../utils/validators/order.validator";
import { protect, restrictTo } from "../middlewares/auth.middleware";

const router = express.Router();

// Protected routes for authenticated users
router.use(protect);

// User order routes
router.get("/my-orders", getMyOrders);
router.get("/my-orders/:id", getOrderDetails);
router.post("/my-orders/:id/cancel", cancelMyOrder);

// Admin only routes
router.use(restrictTo("admin"));

router.get("/admin", adminGetAllOrders);
router.get("/admin/:id", adminGetOrderDetails);
router.put(
  "/admin/:id/status",
  updateOrderStatusValidator,
  adminUpdateOrderStatus
);

export default router;
</file>

<file path="src/routes/payment.routes.ts">
import express from "express";
import {
  createCheckoutSession,
  checkPaymentStatus,
  stripeWebhook,
} from "../controllers/payment.controller";
import { createPaymentIntentValidator } from "../utils/validators/payment.validator";
import { protect } from "../middlewares/auth.middleware";

const router = express.Router();

// Public route for Stripe webhook
// router.post(
//   "/webhook",
//   express.raw({ type: "application/json" }),
//   stripeWebhook
// );

// Protected routes
router.use(protect);

router.post(
  "/create-payment-intent",
  createPaymentIntentValidator,
  createCheckoutSession
);
router.get("/payment-status/:paymentIntentId", checkPaymentStatus);

export default router;
</file>

<file path="src/routes/product.routes.ts">
import express from "express";
import {
  getAllProducts,
  getProduct,
  createNewProduct,
  updateExistingProduct,
  removeProduct,
  searchAllProducts,
  getAllCategories,
  getCategory,
  getProductsInCategory,
} from "../controllers/product.controller";
import {
  createProductValidator,
  updateProductValidator,
} from "../utils/validators/product.validator";
import { protect, restrictTo } from "../middlewares/auth.middleware";

const router = express.Router();

// Public routes
router.get("/", getAllProducts);
router.get("/search", searchAllProducts);
router.get("/categories", getAllCategories);
router.get("/categories/:id", getCategory);
router.get("/categories/:id/products", getProductsInCategory);
router.get("/:id", getProduct);

// Protected routes (admin only)
router.use(protect);
router.use(restrictTo("admin"));

router.post("/", createProductValidator, createNewProduct);
router.put("/:id", updateProductValidator, updateExistingProduct);
router.delete("/:id", removeProduct);

export default router;
</file>

<file path="src/routes/shipping.routes.ts">
import express from "express";
import {
  getShippingRates,
  validateShippingAddress,
  trackOrder,
} from "../controllers/shipping.controller";
import {
  shippingRateValidator,
  addressValidator,
} from "../utils/validators/shipping.validator";

const router = express.Router();

// Calculate shipping rates
router.post("/calculate", shippingRateValidator, getShippingRates);

// Validate address
router.post("/validate-address", addressValidator, validateShippingAddress);

// Get tracking information
router.get("/tracking/:trackingNumber", trackOrder);

export default router;
</file>

<file path="src/routes/user.routes.ts">
import express from "express";
import {
  getProfile,
  updateProfile,
  getAddresses,
  addAddress,
  updateAddress,
  removeAddress,
  adminGetAllUsers,
  adminGetUserDetails,
} from "../controllers/user.controller";
import {
  updateProfileValidator,
  addressValidator,
} from "../utils/validators/user.validator";
import { protect, restrictTo } from "../middlewares/auth.middleware";

const router = express.Router();

// Protected routes
router.use(protect);

// User profile routes
router.get("/me", getProfile);
router.put("/me", updateProfileValidator, updateProfile);

// User address routes
router.get("/me/addresses", getAddresses);
router.post("/me/addresses", addressValidator, addAddress);
router.put("/me/addresses/:id", addressValidator, updateAddress);
router.delete("/me/addresses/:id", removeAddress);

// Admin only routes
router.use(restrictTo("admin"));

router.get("/admin", adminGetAllUsers);
router.get("/admin/:id", adminGetUserDetails);

export default router;
</file>

<file path="src/services/auth.service.ts">
import jwt, { SignOptions } from "jsonwebtoken";
import { getAdminClient, supabaseClient } from "../config/supabase";
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";
import type { StringValue } from "ms";
import { Response } from "express";
// Interface for user registration data
export interface RegisterUserDto {
  email: string;
  password: string;
  first_name: string;
  last_name: string;
  phone?: string;
}

// Interface for user login data
export interface LoginUserDto {
  email: string;
  password: string;
}

// Generate JWT token for a user
export const generateToken = (userId: string): string => {
  const secret = process.env.JWT_SECRET;
  if (!secret) {
    throw new Error("JWT_SECRET is not defined");
  }

  const period: number = parseInt(process.env.JWT_EXPIRES_IN || "7");
  const expiresIn: StringValue = `${period}d`;

  const options: SignOptions = {
    expiresIn: expiresIn,
  };

  return jwt.sign({ id: userId }, secret, options);
};

// Register a new user
export const registerUser = async (userData: RegisterUserDto): Promise<any> => {
  try {
    // First, create auth user in Supabase
    const { data: authData, error: authError } =
      await supabaseClient.auth.signUp({
        email: userData.email,
        password: userData.password,
      });

    if (authError) {
      logger.error("Error registering auth user:", authError);
      throw new AppError(authError.message, 400);
    }

    if (!authData.user) {
      throw new AppError("Failed to create user", 500);
    }
    const adminClient = getAdminClient();
    // Then create the user profile in our users table
    const { data: profileData, error: profileError } = await adminClient
      .from("users")
      .insert([
        {
          id: authData.user.id,
          email: userData.email,
          first_name: userData.first_name,
          last_name: userData.last_name,
          phone: userData.phone || null,
          role: "customer", // Default role
        },
      ])
      .select()
      .single();

    if (profileError) {
      logger.error("Error creating user profile:", profileError);

      // Attempt to clean up the auth user if profile creation fails
      await supabaseClient.auth.admin.deleteUser(authData.user.id);

      throw new AppError(profileError.message, 400);
    }

    return {
      user: profileData,
      token: generateToken(profileData.id),
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in registerUser:", error);
    throw new AppError("Failed to register user", 500);
  }
};

// Login a user
export const loginUser = async (
  loginData: LoginUserDto,
  res?: Response
): Promise<any> => {
  try {
    // Sign in with Supabase Auth
    const { data: authData, error: authError } =
      await supabaseClient.auth.signInWithPassword({
        email: loginData.email,
        password: loginData.password,
      });

    if (authError) {
      logger.error("Error logging in user:", authError);
      throw new AppError("Invalid email or password", 401);
    }

    if (!authData.user) {
      throw new AppError("User not found", 404);
    }

    // Get the user profile from our users table
    const { data: profileData, error: profileError } = await supabaseClient
      .from("users")
      .select("id, email, first_name, last_name, phone, role")
      .eq("id", authData.user.id)
      .single();

    if (profileError) {
      logger.error("Error retrieving user profile:", profileError);
      throw new AppError("User profile not found", 404);
    }

    // Generate JWT token
    const token = generateToken(profileData.id);

    // If response object is provided, set the token as an HTTP-only cookie
    if (res) {
      res.cookie("authToken", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
        sameSite: "lax",
      });
    }

    return {
      user: profileData,
      token: token,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in loginUser:", error);
    throw new AppError("Failed to login", 500);
  }
};

// Send password reset email
export const forgotPassword = async (email: string): Promise<void> => {
  try {
    const { error } = await supabaseClient.auth.resetPasswordForEmail(email, {
      redirectTo: `${process.env.FRONTEND_URL}/reset-password`,
    });

    if (error) {
      logger.error("Error sending password reset email:", error);
      throw new AppError(error.message, 400);
    }
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in forgotPassword:", error);
    throw new AppError("Failed to send password reset email", 500);
  }
};

// Reset password with token
export const resetPassword = async (
  token: string,
  newPassword: string
): Promise<void> => {
  try {
    const { error } = await supabaseClient.auth.updateUser({
      password: newPassword,
    });

    if (error) {
      logger.error("Error resetting password:", error);
      throw new AppError(error.message, 400);
    }
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in resetPassword:", error);
    throw new AppError("Failed to reset password", 500);
  }
};
</file>

<file path="src/services/cart.service.ts">
import { getAdminClient, supabaseClient } from "../config/supabase";
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";
import { v4 as uuidv4 } from "uuid";

// Interface for cart item data
export interface CartItemDto {
  product_id: string;
  quantity: number;
}

// Get or create a cart for a user or session
export const getOrCreateCart = async (userId?: string, sessionId?: string) => {
  try {
    if (!userId && !sessionId) {
      // Generate a new session ID if neither userId nor sessionId is provided
      sessionId = uuidv4();
      console.log("Generated new sessionId:", sessionId);
    }

    // Try to find an existing cart
    let query = supabaseClient.from("carts").select("*");

    if (userId) {
      query = query.eq("user_id", userId);
    } else if (sessionId) {
      query = query.eq("session_id", sessionId);
    }

    const { data: existingCart, error: findError } = await query.maybeSingle();

    if (findError) {
      logger.error("Error finding cart:", findError);
      throw new AppError("Failed to retrieve cart", 500);
    }

    // If cart exists, return it
    if (existingCart) {
      return {
        cart: existingCart,
        isNew: false,
        sessionId: sessionId || null,
      };
    }

    // Identify which client to use (admin client for inserts)
    const adminClient = getAdminClient();

    console.log(
      "Creating new cart with userId:",
      userId,
      "sessionId:",
      sessionId
    );

    // Create a new cart
    const { data: newCart, error: createError } = await adminClient
      .from("carts")
      .insert([
        {
          user_id: userId || null,
          session_id: sessionId || null,
        },
      ])
      .select()
      .single();

    if (createError) {
      logger.error("Error creating cart:", createError);
      throw new AppError("Failed to create cart", 500);
    }

    console.log("New cart created:", newCart);

    return {
      cart: newCart,
      isNew: true,
      sessionId: sessionId || null,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in getOrCreateCart:", error);
    throw new AppError("Failed to manage cart", 500);
  }
};

// Transfer items from session cart to user cart after login
export const mergeSessionCartToUserCart = async (
  userId: string,
  sessionId: string
) => {
  try {
    // Get session cart
    const { data: sessionCart, error: sessionError } = await supabaseClient
      .from("carts")
      .select("id")
      .eq("session_id", sessionId)
      .maybeSingle();

    if (sessionError) {
      logger.error("Error finding session cart:", sessionError);
      throw new AppError("Failed to retrieve session cart", 500);
    }

    // If no session cart, nothing to merge
    if (!sessionCart) {
      return;
    }

    // Get or create user cart
    const { cart: userCart } = await getOrCreateCart(userId);

    // Get items from session cart
    const { data: sessionItems, error: itemsError } = await supabaseClient
      .from("cart_items")
      .select("product_id, quantity")
      .eq("cart_id", sessionCart.id);

    if (itemsError) {
      logger.error("Error retrieving session cart items:", itemsError);
      throw new AppError("Failed to retrieve session cart items", 500);
    }

    if (!sessionItems || sessionItems.length === 0) {
      // No items to transfer
      return;
    }

    // Get existing items in user cart
    const { data: userItems, error: userItemsError } = await supabaseClient
      .from("cart_items")
      .select("id, product_id, quantity")
      .eq("cart_id", userCart.id);

    if (userItemsError) {
      logger.error("Error retrieving user cart items:", userItemsError);
      throw new AppError("Failed to retrieve user cart items", 500);
    }

    // Map product IDs to existing cart items for quick lookup
    const userItemMap = (userItems || []).reduce((map, item) => {
      map[item.product_id] = item;
      return map;
    }, {} as Record<string, any>);

    // Process each session item
    for (const sessionItem of sessionItems) {
      if (userItemMap[sessionItem.product_id]) {
        // Product already in user cart, update quantity
        const { error: updateError } = await supabaseClient
          .from("cart_items")
          .update({
            quantity:
              userItemMap[sessionItem.product_id].quantity +
              sessionItem.quantity,
            updated_at: new Date().toISOString(),
          })
          .eq("id", userItemMap[sessionItem.product_id].id);

        if (updateError) {
          logger.error("Error updating cart item quantity:", updateError);
          // Continue with other items
        }
      } else {
        // Add item to user cart
        const { error: insertError } = await supabaseClient
          .from("cart_items")
          .insert([
            {
              cart_id: userCart.id,
              product_id: sessionItem.product_id,
              quantity: sessionItem.quantity,
            },
          ]);

        if (insertError) {
          logger.error("Error adding item to user cart:", insertError);
          // Continue with other items
        }
      }
    }

    // Delete session cart and its items (cascade should handle items)
    const { error: deleteError } = await supabaseClient
      .from("carts")
      .delete()
      .eq("id", sessionCart.id);

    if (deleteError) {
      logger.error("Error deleting session cart:", deleteError);
      // Not critical, continue
    }
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in mergeSessionCartToUserCart:", error);
    throw new AppError("Failed to merge carts", 500);
  }
};

// Add an item to the cart
export const addItemToCart = async (
  cartId: string,
  itemData: CartItemDto,
  sessionId?: string
) => {
  try {
    // Check if product exists and is active
    const { data: product, error: productError } = await supabaseClient
      .from("products")
      .select("id, inventory_quantity, is_active")
      .eq("id", itemData.product_id)
      .eq("is_active", true)
      .single();

    if (productError || !product) {
      logger.error("Error finding product:", productError);
      throw new AppError("Product not found or not available", 404);
    }

    // Check if product is in stock
    if (product.inventory_quantity < itemData.quantity) {
      throw new AppError(
        `Only ${product.inventory_quantity} items available in stock`,
        400
      );
    }

    // Create a client with session ID header if available
    const client = supabaseClient.from("cart_items");
    if (sessionId) {
      client.headers = { "cart-session-id": sessionId };
    }

    // Check if item already exists in cart
    const { data: existingItem, error: itemError } = await client
      .select("id, quantity")
      .eq("cart_id", cartId)
      .eq("product_id", itemData.product_id)
      .maybeSingle();

    if (itemError) {
      logger.error("Error checking existing cart item:", itemError);
      throw new AppError("Failed to check existing cart item", 500);
    }

    if (existingItem) {
      // Update existing item quantity
      const newQuantity = existingItem.quantity + itemData.quantity;

      // Check updated quantity against inventory
      if (newQuantity > product.inventory_quantity) {
        throw new AppError(
          `Cannot add more items. Only ${product.inventory_quantity} available in stock`,
          400
        );
      }

      const { data: updatedItem, error: updateError } = await client
        .update({
          quantity: newQuantity,
          updated_at: new Date().toISOString(),
        })
        .eq("id", existingItem.id)
        .select()
        .single();

      if (updateError) {
        logger.error("Error updating cart item:", updateError);
        throw new AppError("Failed to update cart item", 500);
      }

      return updatedItem;
    } else {
      // Add new item to cart
      const { data: newItem, error: addError } = await client
        .insert([
          {
            cart_id: cartId,
            product_id: itemData.product_id,
            quantity: itemData.quantity,
          },
        ])
        .select()
        .single();

      if (addError) {
        logger.error("Error adding item to cart:", addError);
        throw new AppError("Failed to add item to cart", 500);
      }

      return newItem;
    }
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in addItemToCart:", error);
    throw new AppError("Failed to add item to cart", 500);
  }
};

// Update cart item quantity
export const updateCartItem = async (
  cartId: string,
  itemId: string,
  quantity: number,
  sessionId?: string
) => {
  try {
    // Clean the item ID to ensure no extra quotes
    const cleanItemId = itemId.replace(/"/g, "");

    // Create a client with session ID header if available
    const client = supabaseClient.from("cart_items");
    if (sessionId) {
      client.headers = { "cart-session-id": sessionId };
    }

    // Check if item exists in the cart
    const { data: existingItem, error: itemError } = await client
      .select("id, product_id")
      .eq("id", cleanItemId)
      .eq("cart_id", cartId)
      .single();

    if (itemError || !existingItem) {
      logger.error("Error finding cart item:", itemError);
      throw new AppError("Cart item not found", 404);
    }

    // Check if product exists and is active
    const { data: product, error: productError } = await supabaseClient
      .from("products")
      .select("id, inventory_quantity, is_active")
      .eq("id", existingItem.product_id)
      .eq("is_active", true)
      .single();

    if (productError || !product) {
      logger.error("Error finding product:", productError);
      throw new AppError("Product not found or not available", 404);
    }

    // Check if product is in stock
    if (product.inventory_quantity < quantity) {
      throw new AppError(
        `Only ${product.inventory_quantity} items available in stock`,
        400
      );
    }

    // Update the item quantity
    const { data: updatedItem, error: updateError } = await client
      .update({
        quantity,
        updated_at: new Date().toISOString(),
      })
      .eq("id", cleanItemId)
      .select()
      .single();

    if (updateError) {
      logger.error("Error updating cart item:", updateError);
      throw new AppError("Failed to update cart item", 500);
    }

    return updatedItem;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in updateCartItem:", error);
    throw new AppError("Failed to update cart item", 500);
  }
};

// Remove an item from the cart
export const removeCartItem = async (
  cartId: string,
  itemId: string,
  sessionId?: string
) => {
  try {
    console.log("Removing item from cart:", itemId);
    // Clean the item ID to ensure no extra quotes
    const cleanItemId = itemId.replace(/"/g, "");

    // Create a client with session ID header if available
    const client = supabaseClient.from("cart_items");
    if (sessionId) {
      client.headers = { "cart-session-id": sessionId };
    }
    // Check if item exists in the cart
    const { data: existingItem, error: itemError } = await client
      .select("id")
      .eq("id", cleanItemId)
      .eq("cart_id", cartId)
      .single();

    if (itemError || !existingItem) {
      logger.error("Error finding cart item:", itemError);
      throw new AppError("Cart item not found", 404);
    }

    // Remove the item
    const { error: deleteError } = await supabaseClient
      .from("cart_items")
      .delete()
      .eq("id", cleanItemId);

    if (deleteError) {
      logger.error("Error removing cart item:", deleteError);
      throw new AppError("Failed to remove cart item", 500);
    }

    return { success: true };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in removeCartItem:", error);
    throw new AppError("Failed to remove cart item", 500);
  }
};

// Get cart with items and product details
export const getCartWithItems = async (cartId: string, sessionId?: string) => {
  try {
    // Create clients with session ID header if available
    const cartClient = supabaseClient.from("carts");
    const itemsClient = supabaseClient.from("cart_items");

    if (sessionId) {
      cartClient.headers = { "cart-session-id": sessionId };
      itemsClient.headers = { "cart-session-id": sessionId };
    }

    // Get cart
    const { data: cart, error: cartError } = await cartClient
      .select("id, user_id, session_id, created_at, updated_at")
      .eq("id", cartId)
      .single();

    if (cartError || !cart) {
      logger.error("Error finding cart:", cartError);
      throw new AppError("Cart not found", 404);
    }

    // Get cart items with product details
    const { data: cartItems, error: itemsError } = await itemsClient
      .select(
        `
        id, 
        quantity, 
        created_at, 
        updated_at,
        products:product_id (
          id, 
          name, 
          price, 
          compare_at_price, 
          sku, 
          weight, 
          dimensions,
          inventory_quantity,
          product_images (
            url, 
            alt_text, 
            is_primary
          )
        )
      `
      )
      .eq("cart_id", cartId);

    if (itemsError) {
      logger.error("Error retrieving cart items:", itemsError);
      throw new AppError("Failed to retrieve cart items", 500);
    }

    // Calculate cart totals
    let subtotal = 0;
    let totalItems = 0;

    if (cartItems) {
      cartItems.forEach((item) => {
        // Check if products is an array or object
        const product = Array.isArray(item.products)
          ? item.products[0]
          : item.products;

        // Check that we have valid product data
        if (product && product.price) {
          subtotal += product.price * item.quantity;
        }
        totalItems += item.quantity;
      });
    }

    return {
      cart,
      items: cartItems || [],
      summary: {
        subtotal,
        totalItems,
      },
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    // Add detailed error logging
    logger.error("Unexpected error in getCartWithItems:", error);
    console.log("Error details:", error);
    throw new AppError("Failed to retrieve cart", 500);
  }
};

// Clear all items from the cart
export const clearCart = async (cartId: string) => {
  try {
    // Delete all items in the cart
    const { error: deleteError } = await supabaseClient
      .from("cart_items")
      .delete()
      .eq("cart_id", cartId);

    if (deleteError) {
      logger.error("Error clearing cart:", deleteError);
      throw new AppError("Failed to clear cart", 500);
    }

    return { success: true };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in clearCart:", error);
    throw new AppError("Failed to clear cart", 500);
  }
};
</file>

<file path="src/services/order.service.ts">
import { applyFilterIf, getPaginatedData } from "@/utils/query-helper";
import { supabaseClient, getAdminClient } from "../config/supabase";
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";
import { generateShippingLabel } from "./shipping.service";

// Interface for pagination parameters
export interface OrderPaginationParams {
  page?: number;
  limit?: number;
  status?: string;
  sort_by?: string;
  sort_order?: "asc" | "desc";
  start_date?: string;
  end_date?: string;
}

// Get all orders for a user
export const getUserOrders = async (
  userId: string,
  params: OrderPaginationParams = {}
) => {
  try {
    const {
      page = 1,
      limit = 10,
      status,
      sort_by = "created_at",
      sort_order = "desc",
      start_date,
      end_date,
    } = params;

    // Define filters function
    const applyFilters = (query: any) => {
      // First filter by user ID
      query = query.eq("user_id", userId);

      // Apply other filters conditionally
      return applyFilterIf(
        applyFilterIf(
          applyFilterIf(query, !!status, (q) => q.eq("status", status)),
          !!start_date,
          (q) => q.gte("created_at", start_date)
        ),
        !!end_date,
        (q) => q.lte("created_at", end_date)
      );
    };

    // Use the utility function to get paginated data
    const result = await getPaginatedData({
      client: supabaseClient,
      table: "orders",
      options: {
        page,
        limit,
        sortBy: sort_by,
        sortOrder: sort_order as "asc" | "desc",
      },
      select: `
        *,
        order_items (
          id,
          product_id,
          quantity,
          unit_price,
          total_price,
          products:product_id (
            id,
            name,
            sku,
            product_images (
              url,
              alt_text,
              is_primary
            )
          )
        ),
        shipping_addresses:shipping_address_id (
          *
        ),
        billing_addresses:billing_address_id (
          *
        )
      `,
      applyFilters,
    });

    return {
      orders: result.data,
      pagination: result.pagination,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in getUserOrders:", error);
    throw new AppError("Failed to get orders", 500);
  }
};

// Get a single order by ID
export const getOrderById = async (orderId: string, userId?: string) => {
  try {
    let orderQuery = supabaseClient
      .from("orders")
      .select(
        `
        *,
        order_items (
          id,
          product_id,
          quantity,
          unit_price,
          total_price,
          products:product_id (
            id,
            name,
            sku,
            product_images (
              url,
              alt_text,
              is_primary
            )
          )
        ),
        shipping_addresses:shipping_address_id (
          *
        ),
        billing_addresses:billing_address_id (
          *
        )
      `
      )
      .eq("id", orderId);

    // If userId is provided, restrict to that user's orders
    if (userId) {
      orderQuery = orderQuery.eq("user_id", userId);
    }

    const { data: order, error } = await orderQuery.single();

    if (error) {
      logger.error(`Error getting order ${orderId}:`, error);
      throw new AppError("Order not found", 404);
    }

    return order;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in getOrderById for ${orderId}:`, error);
    throw new AppError("Failed to get order", 500);
  }
};

// Cancel an order
export const cancelOrder = async (orderId: string, userId: string) => {
  try {
    // Check if order exists and belongs to user
    const { data: order, error: orderError } = await supabaseClient
      .from("orders")
      .select("id, status, user_id")
      .eq("id", orderId)
      .eq("user_id", userId)
      .single();

    if (orderError || !order) {
      logger.error(
        `Order ${orderId} not found for user ${userId}:`,
        orderError
      );
      throw new AppError("Order not found", 404);
    }

    // Check if order can be canceled
    const cancelableStatuses = ["pending", "paid", "processing"];
    if (!cancelableStatuses.includes(order.status)) {
      throw new AppError(
        `Order in ${order.status} status cannot be cancelled`,
        400
      );
    }

    // Update order status
    const adminClient = getAdminClient();
    const { error: updateError } = await adminClient
      .from("orders")
      .update({
        status: "cancelled",
        updated_at: new Date().toISOString(),
      })
      .eq("id", orderId);

    if (updateError) {
      logger.error(`Error cancelling order ${orderId}:`, updateError);
      throw new AppError("Failed to cancel order", 500);
    }

    // Get order items to update inventory
    const { data: orderItems, error: itemsError } = await supabaseClient
      .from("order_items")
      .select("product_id, quantity")
      .eq("order_id", orderId);

    if (itemsError) {
      logger.error(`Error getting order items for ${orderId}:`, itemsError);
      // Continue with the process
    } else if (orderItems && orderItems.length > 0) {
      // Restore inventory
      for (const item of orderItems) {
        const { error: inventoryError } = await adminClient
          //.from("products")
          .rpc("increment_inventory", {
            p_product_id: item.product_id,
            p_quantity: item.quantity,
          });

        if (inventoryError) {
          logger.error(
            `Error restoring inventory for product ${item.product_id}:`,
            inventoryError
          );
          // Continue with other items
        }
      }
    }

    return { success: true, message: "Order cancelled successfully" };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in cancelOrder for ${orderId}:`, error);
    throw new AppError("Failed to cancel order", 500);
  }
};

// Update order status (admin only)
export const updateOrderStatus = async (
  orderId: string,
  status: string,
  trackingNumber?: string
) => {
  try {
    const adminClient = getAdminClient();

    // Check if order exists
    const { data: order, error: orderError } = await adminClient
      .from("orders")
      .select("id, status")
      .eq("id", orderId)
      .single();

    if (orderError || !order) {
      logger.error(`Order ${orderId} not found:`, orderError);
      throw new AppError("Order not found", 404);
    }

    // Valid order statuses
    const validStatuses = [
      "pending",
      "paid",
      "processing",
      "shipped",
      "delivered",
      "cancelled",
      "refunded",
    ];
    if (!validStatuses.includes(status)) {
      throw new AppError("Invalid order status", 400);
    }

    // If status is shipped and no tracking number provided, generate one
    if (status === "shipped" && !trackingNumber) {
      // Get order details to generate label
      const { data: fullOrder, error: fetchError } = await adminClient
        .from("orders")
        .select(
          `
            id,
            shipping_method,
            shipping_address_id,
            order_items (
              id,
              product_id,
              quantity,
              products:product_id (id, weight, dimensions)
            )
          `
        )
        .eq("id", orderId)
        .single();

      if (fetchError || !fullOrder) {
        logger.error(
          `Error fetching full order details for ${orderId}:`,
          fetchError
        );
        throw new AppError("Failed to fetch order details", 500);
      }

      // Now fetch the shipping address separately
      const { data: shippingAddress, error: addressError } = await adminClient
        .from("addresses")
        .select("*")
        .eq("id", fullOrder.shipping_address_id)
        .single();

      if (addressError || !shippingAddress) {
        logger.error(
          `Error fetching shipping address for ${orderId}:`,
          addressError
        );
        throw new AppError("Failed to fetch shipping address", 500);
      }

      // Prepare data for label generation
      const fromAddress = {
        address_line1: "123 Warehouse St",
        address_line2: "",
        city: "Metropolis",
        state: "NY",
        postal_code: "10001",
        country: "US",
      };

      // Prepare items for shipping
      const items = fullOrder.order_items.map((item) => {
        // Handle potential array or object structure for products
        const product = Array.isArray(item.products)
          ? item.products[0]
          : item.products;

        return {
          product_id: item.product_id,
          quantity: item.quantity,
          weight: product.weight,
          dimensions: product.dimensions,
        };
      });

      const { trackingNumber: newTrackingNumber } = await generateShippingLabel(
        orderId,
        fullOrder.shipping_method,
        fromAddress,
        shippingAddress,
        items
      );
      trackingNumber = newTrackingNumber;
    }

    // Update order
    const updateData: any = {
      status,
      updated_at: new Date().toISOString(),
    };

    if (trackingNumber) {
      updateData.tracking_number = trackingNumber;
    }

    const { error: updateError } = await adminClient
      .from("orders")
      .update(updateData)
      .eq("id", orderId);

    if (updateError) {
      logger.error(`Error updating order ${orderId}:`, updateError);
      throw new AppError("Failed to update order", 500);
    }

    return {
      success: true,
      message: `Order status updated to ${status}`,
      trackingNumber: trackingNumber || null,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(
      `Unexpected error in updateOrderStatus for ${orderId}:`,
      error
    );
    throw new AppError("Failed to update order status", 500);
  }
};

// Get all orders (admin only)
export const getAllOrders = async (params: OrderPaginationParams = {}) => {
  try {
    const {
      page = 1,
      limit = 10,
      status,
      sort_by = "created_at",
      sort_order = "desc",
      start_date,
      end_date,
    } = params;

    // Get admin client
    const adminClient = getAdminClient();

    // Define filters function
    const applyFilters = (query: any) => {
      // Apply filters conditionally
      return applyFilterIf(
        applyFilterIf(
          applyFilterIf(query, !!status, (q) => q.eq("status", status)),
          !!start_date,
          (q) => q.gte("created_at", start_date)
        ),
        !!end_date,
        (q) => q.lte("created_at", end_date)
      );
    };

    // Use the utility function to get paginated data
    const result = await getPaginatedData({
      client: adminClient,
      table: "orders",
      options: {
        page,
        limit,
        sortBy: sort_by,
        sortOrder: sort_order as "asc" | "desc",
      },
      select: `
        *,
        users:user_id (
          id,
          email,
          first_name,
          last_name
        )
      `,
      applyFilters,
    });

    return {
      orders: result.data,
      pagination: result.pagination,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in getAllOrders:", error);
    throw new AppError("Failed to get orders", 500);
  }
};
</file>

<file path="src/services/payment.service.ts">
import stripe from "../config/stripe";
import { supabaseClient, getAdminClient } from "../config/supabase";
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";
import { getCartWithItems } from "./cart.service";
import { calculateShippingRates } from "./shipping.service";

// Interface for payment intent data
export interface CreatePaymentIntentDto {
  cartId: string;
  customerId?: string;
  shipping_address_id: string;
  billing_address_id: string;
  shipping_method: string;
  metadata?: Record<string, string>;
}

// Interface for payment method data
export interface SetupPaymentMethodDto {
  paymentIntentId: string;
  paymentMethodId: string;
}

// Create a payment intent for checkout
export const createPaymentIntent = async (data: CreatePaymentIntentDto) => {
  try {
    // Get cart with items
    const { cart, items, summary } = await getCartWithItems(data.cartId);

    if (!items || items.length === 0) {
      throw new AppError("Cart is empty", 400);
    }

    // Get shipping address for rate calculation
    const { data: shippingAddress, error: addressError } = await supabaseClient
      .from("addresses")
      .select("*")
      .eq("id", data.shipping_address_id)
      .single();

    if (addressError || !shippingAddress) {
      logger.error("Error retrieving shipping address:", addressError);
      throw new AppError("Shipping address not found", 404);
    }

    // Calculate shipping cost
    const shippingRates = await calculateShippingRates({
      address: shippingAddress,
      items: items.map((item) => {
        // Check if products is an array or object
        const product = Array.isArray(item.products)
          ? item.products[0]
          : item.products;

        return {
          product_id: product.id,
          quantity: item.quantity,
          weight: product.weight,
          dimensions: product.dimensions,
        };
      }),
    });

    // Find selected shipping method
    const selectedShipping = shippingRates.find(
      (rate) => rate.service_code === data.shipping_method
    );

    if (!selectedShipping) {
      throw new AppError("Selected shipping method not available", 400);
    }

    // Calculate tax (simplified - in a real implementation, use a tax API)
    const taxRate = 0.07; // 7% tax rate - this should come from a tax service based on location
    const taxAmount = Math.round(summary.subtotal * taxRate);

    // Calculate order total
    const totalAmount = Math.round(
      summary.subtotal + taxAmount + selectedShipping.rate
    );

    // Create a payment intent with Stripe
    const paymentIntent = await stripe.paymentIntents.create({
      amount: totalAmount,
      currency: "usd",
      customer: data.customerId,
      metadata: {
        cart_id: data.cartId,
        user_id: cart.user_id || "",
        shipping_address_id: data.shipping_address_id,
        billing_address_id: data.billing_address_id,
        shipping_method: data.shipping_method,
        ...(data.metadata || {}),
      },
    });

    console.log("Payment intent:", paymentIntent);

    return {
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id,
      amount: totalAmount,
      subtotal: summary.subtotal,
      tax: taxAmount,
      shipping: selectedShipping.rate,
      currency: "usd",
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    console.error("Full error details:", error);

    // Type guard for error object
    if (error && typeof error === "object") {
      if ("message" in error) console.error("Error message:", error.message);
      if ("stack" in error) console.error("Stack trace:", error.stack);
    }

    logger.error("Unexpected error in createPaymentIntent:", error);
    throw new AppError("Failed to create payment intent", 500);
  }
};

// Confirm a payment intent
export const confirmPaymentIntent = async (paymentIntentId: string) => {
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

    if (paymentIntent.status === "succeeded") {
      // Create order from payment intent metadata
      if (paymentIntent.metadata.cart_id) {
        await createOrderFromPaymentIntent(paymentIntent);
      }

      return {
        status: paymentIntent.status,
        paymentIntentId: paymentIntent.id,
      };
    }

    return {
      status: paymentIntent.status,
      paymentIntentId: paymentIntent.id,
    };
  } catch (error) {
    logger.error("Error confirming payment intent:", error);
    throw new AppError("Failed to confirm payment", 500);
  }
};

// Handle Stripe webhook events
export const handleStripeWebhook = async (event: any) => {
  try {
    switch (event.type) {
      case "payment_intent.succeeded":
        const paymentIntent = event.data.object;
        await createOrderFromPaymentIntent(paymentIntent);
        break;

      case "payment_intent.payment_failed":
        // Handle payment failure
        logger.warn("Payment failed:", event.data.object);
        break;

      default:
        // Unexpected event type
        logger.info(`Unhandled event type: ${event.type}`);
    }

    return { received: true };
  } catch (error) {
    logger.error("Error handling Stripe webhook:", error);
    throw new AppError("Failed to process webhook", 500);
  }
};

// Create an order from a successful payment intent
export const createOrderFromPaymentIntent = async (paymentIntent: any) => {
  try {
    const { metadata } = paymentIntent;

    // Verify that an order hasn't already been created for this payment
    const { data: existingOrder, error: orderCheckError } = await supabaseClient
      .from("orders")
      .select("id")
      .eq("stripe_payment_intent_id", paymentIntent.id)
      .maybeSingle();

    if (orderCheckError) {
      logger.error("Error checking existing order:", orderCheckError);
      throw new AppError("Failed to check existing order", 500);
    }

    // If order already exists, don't create a duplicate
    if (existingOrder) {
      logger.info(
        `Order already exists for payment intent ${paymentIntent.id}`
      );
      return { orderId: existingOrder.id };
    }

    // Get cart with items
    const { items, summary } = await getCartWithItems(metadata.cart_id);

    if (!items || items.length === 0) {
      throw new AppError("Cart is empty", 400);
    }

    // Get shipping address
    const { data: shippingAddress, error: shippingAddressError } =
      await supabaseClient
        .from("addresses")
        .select("*")
        .eq("id", metadata.shipping_address_id)
        .single();

    if (shippingAddressError || !shippingAddress) {
      logger.error("Error retrieving shipping address:", shippingAddressError);
      throw new AppError("Shipping address not found", 404);
    }

    // Get billing address
    const { data: billingAddress, error: billingAddressError } =
      await supabaseClient
        .from("addresses")
        .select("*")
        .eq("id", metadata.billing_address_id)
        .single();

    if (billingAddressError || !billingAddress) {
      logger.error("Error retrieving billing address:", billingAddressError);
      throw new AppError("Billing address not found", 404);
    }

    // Calculate shipping cost (use the saved shipping method from metadata)
    const shippingRates = await calculateShippingRates({
      address: shippingAddress,
      items: items.map((item) => {
        // Ensure product is retrieved correctly whether it's an object or first element of array
        const product = Array.isArray(item.products)
          ? item.products[0]
          : item.products;

        // Ensure dimensions has the expected structure
        const dimensions = product.dimensions as {
          length: number;
          width: number;
          height: number;
        };

        return {
          product_id: product.id,
          quantity: item.quantity,
          weight: product.weight,
          dimensions: dimensions,
        };
      }),
    });

    const selectedShipping = shippingRates.find(
      (rate) => rate.service_code === metadata.shipping_method
    );

    if (!selectedShipping) {
      throw new AppError("Selected shipping method not available", 400);
    }

    // Calculate tax
    const taxRate = 0.07; // 7% tax rate
    const taxAmount = Math.round(summary.subtotal * taxRate);

    // Create order
    const adminClient = getAdminClient();

    const { data: order, error: orderError } = await adminClient
      .from("orders")
      .insert([
        {
          user_id: metadata.user_id || null,
          status: "paid",
          total_amount: paymentIntent.amount,
          subtotal: summary.subtotal,
          tax: taxAmount,
          shipping_cost: selectedShipping.rate,
          discount_amount: 0, // No discount in this example
          stripe_payment_intent_id: paymentIntent.id,
          billing_address_id: metadata.billing_address_id,
          shipping_address_id: metadata.shipping_address_id,
          shipping_method: metadata.shipping_method,
          tracking_number: null, // Will be added later when shipped
          notes: null,
        },
      ])
      .select()
      .single();

    if (orderError) {
      logger.error("Error creating order:", orderError);
      throw new AppError("Failed to create order", 500);
    }

    // Add order items
    const orderItems = items.map((item) => {
      // Ensure product is retrieved correctly whether it's an object or first element of array
      const product = Array.isArray(item.products)
        ? item.products[0]
        : item.products;

      return {
        order_id: order.id,
        product_id: product.id,
        quantity: item.quantity,
        unit_price: product.price,
        total_price: product.price * item.quantity,
      };
    });

    const { error: itemsError } = await adminClient
      .from("order_items")
      .insert(orderItems);

    if (itemsError) {
      logger.error("Error adding order items:", itemsError);
      throw new AppError("Failed to add order items", 500);
    }

    // Update product inventory
    for (const item of items) {
      // Get the product from the array - assuming it's the first item
      const product = Array.isArray(item.products)
        ? item.products[0]
        : item.products;

      const { error: inventoryError } = await adminClient
        .from("products")
        .update({
          inventory_quantity: product.inventory_quantity - item.quantity,
          updated_at: new Date().toISOString(),
        })
        .eq("id", product.id);

      if (inventoryError) {
        logger.error(
          `Error updating inventory for product ${product.id}:`,
          inventoryError
        );
        // Continue with other items
      }
    }

    // Clear the cart
    await adminClient
      .from("cart_items")
      .delete()
      .eq("cart_id", metadata.cart_id);

    return { orderId: order.id };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in createOrderFromPaymentIntent:", error);
    throw new AppError("Failed to create order from payment", 500);
  }
};
</file>

<file path="src/services/product.service.ts">
import { applyFilterIf, getPaginatedData } from "../utils/query-helper";
import { supabaseClient, getAdminClient } from "../config/supabase";
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";

// Interface for product data
export interface ProductDto {
  name: string;
  description: string;
  price: number;
  compare_at_price?: number;
  cost_price: number;
  sku: string;
  barcode?: string;
  weight: number;
  dimensions: {
    length: number;
    width: number;
    height: number;
  };
  inventory_quantity: number;
  is_active?: boolean;
  category_id: string;
  images?: {
    url: string;
    alt_text: string;
    position: number;
    is_primary?: boolean;
  }[];
}

// Interface for pagination parameters
export interface PaginationParams {
  page?: number;
  limit?: number;
  sort_by?: string;
  sort_order?: "asc" | "desc";
  category_id?: string;
  query?: string;
  min_price?: number;
  max_price?: number;
  in_stock?: boolean;
}

// Get all products with pagination and filtering
export const getProducts = async (params: PaginationParams = {}) => {
  try {
    const {
      page = 1,
      limit = 20,
      sort_by = "created_at",
      sort_order = "desc",
      category_id,
      query: searchQuery,
      min_price,
      max_price,
      in_stock,
    } = params;

    // Define filters function
    const applyFilters = (query: any) => {
      // Build filter chain
      return applyFilterIf(
        applyFilterIf(
          applyFilterIf(
            applyFilterIf(
              applyFilterIf(query, !!category_id, (q) =>
                q.eq("category_id", category_id)
              ),
              !!searchQuery,
              (q) =>
                q.or(
                  `name.ilike.%${searchQuery}%,description.ilike.%${searchQuery}%,sku.ilike.%${searchQuery}%`
                )
            ),
            min_price !== undefined,
            (q) => q.gte("price", min_price)
          ),
          max_price !== undefined,
          (q) => q.lte("price", max_price)
        ),
        !!in_stock,
        (q) => q.gt("inventory_quantity", 0)
      ).eq("is_active", true);
    };

    // Use the utility function to get paginated data
    const result = await getPaginatedData({
      client: supabaseClient,
      table: "products",
      options: {
        page,
        limit,
        sortBy: sort_by,
        sortOrder: sort_order as "asc" | "desc",
      },
      select: `
        *,
        product_images (*),
        categories:category_id (id, name, slug)
      `,
      applyFilters,
    });

    return {
      products: result.data,
      pagination: result.pagination,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in getProducts:", error);
    throw new AppError("Failed to get products", 500);
  }
};

// Get a single product by ID
export const getProductById = async (productId: string) => {
  try {
    const { data: product, error } = await supabaseClient
      .from("products")
      .select(
        `
        *,
        product_images (*),
        categories:category_id (id, name, slug)
      `
      )
      .eq("id", productId)
      .eq("is_active", true)
      .single();

    if (error) {
      logger.error(`Error getting product ${productId}:`, error);
      throw new AppError("Product not found", 404);
    }

    return product;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in getProductById for ${productId}:`, error);
    throw new AppError("Failed to get product", 500);
  }
};

// Create a new product (admin only)
export const createProduct = async (productData: ProductDto) => {
  try {
    const adminClient = getAdminClient();

    // Start a transaction by using the supabase connection directly
    const { data: product, error } = await adminClient
      .from("products")
      .insert([
        {
          name: productData.name,
          description: productData.description,
          price: productData.price,
          compare_at_price: productData.compare_at_price,
          cost_price: productData.cost_price,
          sku: productData.sku,
          barcode: productData.barcode,
          weight: productData.weight,
          dimensions: productData.dimensions,
          inventory_quantity: productData.inventory_quantity,
          is_active:
            productData.is_active !== undefined ? productData.is_active : true,
          category_id: productData.category_id,
        },
      ])
      .select()
      .single();

    if (error) {
      logger.error("Error creating product:", error);
      throw new AppError(error.message, 400);
    }

    // If there are images, add them
    if (productData.images && productData.images.length > 0) {
      const imagesToInsert = productData.images.map((image) => ({
        product_id: product.id,
        url: image.url,
        alt_text: image.alt_text,
        position: image.position,
        is_primary: image.is_primary !== undefined ? image.is_primary : false,
      }));

      const { error: imageError } = await adminClient
        .from("product_images")
        .insert(imagesToInsert);

      if (imageError) {
        logger.error("Error adding product images:", imageError);
        throw new AppError("Failed to add product images", 500);
      }
    }

    // Get the complete product with images
    const { data: completeProduct, error: fetchError } = await adminClient
      .from("products")
      .select(
        `
        *,
        product_images (*),
        categories:category_id (id, name, slug)
      `
      )
      .eq("id", product.id)
      .single();

    if (fetchError) {
      logger.error("Error fetching complete product:", fetchError);
      throw new AppError("Failed to fetch complete product", 500);
    }

    return completeProduct;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in createProduct:", error);
    throw new AppError("Failed to create product", 500);
  }
};

// Update an existing product (admin only)
export const updateProduct = async (
  productId: string,
  productData: Partial<ProductDto>
) => {
  try {
    const adminClient = getAdminClient();

    // Check if product exists
    const { data: existingProduct, error: checkError } = await adminClient
      .from("products")
      .select("id")
      .eq("id", productId)
      .single();

    if (checkError || !existingProduct) {
      logger.error(`Product with ID ${productId} not found:`, checkError);
      throw new AppError("Product not found", 404);
    }

    // Update product
    const { data: product, error } = await adminClient
      .from("products")
      .update({
        name: productData.name,
        description: productData.description,
        price: productData.price,
        compare_at_price: productData.compare_at_price,
        cost_price: productData.cost_price,
        sku: productData.sku,
        barcode: productData.barcode,
        weight: productData.weight,
        dimensions: productData.dimensions,
        inventory_quantity: productData.inventory_quantity,
        is_active: productData.is_active,
        category_id: productData.category_id,
        updated_at: new Date().toISOString(),
      })
      .eq("id", productId)
      .select()
      .single();

    if (error) {
      logger.error(`Error updating product ${productId}:`, error);
      throw new AppError(error.message, 400);
    }

    // If there are images, update them
    if (productData.images) {
      // First, delete existing images
      const { error: deleteError } = await adminClient
        .from("product_images")
        .delete()
        .eq("product_id", productId);

      if (deleteError) {
        logger.error(
          `Error deleting product images for ${productId}:`,
          deleteError
        );
        throw new AppError("Failed to update product images", 500);
      }

      // Then, add new images
      const imagesToInsert = productData.images.map((image) => ({
        product_id: productId,
        url: image.url,
        alt_text: image.alt_text,
        position: image.position,
        is_primary: image.is_primary !== undefined ? image.is_primary : false,
      }));

      if (imagesToInsert.length > 0) {
        const { error: imageError } = await adminClient
          .from("product_images")
          .insert(imagesToInsert);

        if (imageError) {
          logger.error(
            `Error adding new product images for ${productId}:`,
            imageError
          );
          throw new AppError("Failed to add new product images", 500);
        }
      }
    }

    // Get the complete updated product with images
    const { data: completeProduct, error: fetchError } = await adminClient
      .from("products")
      .select(
        `
        *,
        product_images (*),
        categories:category_id (id, name, slug)
      `
      )
      .eq("id", productId)
      .single();

    if (fetchError) {
      logger.error(
        `Error fetching complete updated product ${productId}:`,
        fetchError
      );
      throw new AppError("Failed to fetch complete updated product", 500);
    }

    return completeProduct;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in updateProduct for ${productId}:`, error);
    throw new AppError("Failed to update product", 500);
  }
};

// Delete a product (admin only)
export const deleteProduct = async (productId: string) => {
  try {
    const adminClient = getAdminClient();

    // Check if product exists
    const { data: existingProduct, error: checkError } = await adminClient
      .from("products")
      .select("id")
      .eq("id", productId)
      .single();

    if (checkError || !existingProduct) {
      logger.error(`Product with ID ${productId} not found:`, checkError);
      throw new AppError("Product not found", 404);
    }

    // First, delete related images
    const { error: imageError } = await adminClient
      .from("product_images")
      .delete()
      .eq("product_id", productId);

    if (imageError) {
      logger.error(
        `Error deleting product images for ${productId}:`,
        imageError
      );
      throw new AppError("Failed to delete product images", 500);
    }

    // Then, delete the product
    const { error } = await adminClient
      .from("products")
      .delete()
      .eq("id", productId);

    if (error) {
      logger.error(`Error deleting product ${productId}:`, error);
      throw new AppError("Failed to delete product", 500);
    }

    return { success: true };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in deleteProduct for ${productId}:`, error);
    throw new AppError("Failed to delete product", 500);
  }
};

// Get products by category
export const getProductsByCategory = async (
  categoryId: string,
  params: PaginationParams = {}
) => {
  try {
    // Set category filter and call getProducts
    return await getProducts({
      ...params,
      category_id: categoryId,
    });
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(
      `Unexpected error in getProductsByCategory for ${categoryId}:`,
      error
    );
    throw new AppError("Failed to get products by category", 500);
  }
};

// Search products
export const searchProducts = async (
  searchQuery: string,
  params: PaginationParams = {}
) => {
  try {
    // Set search query and call getProducts
    return await getProducts({
      ...params,
      query: searchQuery,
    });
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(
      `Unexpected error in searchProducts for query "${searchQuery}":`,
      error
    );
    throw new AppError("Failed to search products", 500);
  }
};

// Get all product categories
export const getCategories = async () => {
  try {
    const { data: categories, error } = await supabaseClient
      .from("categories")
      .select("*")
      .order("name");

    if (error) {
      logger.error("Error getting categories:", error);
      throw new AppError("Failed to get categories", 500);
    }

    return categories;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in getCategories:", error);
    throw new AppError("Failed to get categories", 500);
  }
};

// Get a single category by ID
export const getCategoryById = async (categoryId: string) => {
  try {
    const { data: category, error } = await supabaseClient
      .from("categories")
      .select("*")
      .eq("id", categoryId)
      .single();

    if (error) {
      logger.error(`Error getting category ${categoryId}:`, error);
      throw new AppError("Category not found", 404);
    }

    return category;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(
      `Unexpected error in getCategoryById for ${categoryId}:`,
      error
    );
    throw new AppError("Failed to get category", 500);
  }
};
</file>

<file path="src/services/shipping.service.ts">
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";

// Interfaces
export interface ShippingAddress {
  address_line1: string;
  address_line2?: string | null;
  city: string;
  state: string;
  postal_code: string;
  country: string;
}

export interface ShippingItem {
  product_id: string;
  quantity: number;
  weight: number;
  dimensions: {
    length: number;
    width: number;
    height: number;
  };
}

export interface ShippingRateRequest {
  address: ShippingAddress;
  items: ShippingItem[];
}

export interface ShippingRate {
  service_code: string;
  service_name: string;
  rate: number;
  estimated_days: number;
}

// Simplified shipping rate calculation
// In a real application, this would call a shipping API
export const calculateShippingRates = async (
  request: ShippingRateRequest
): Promise<ShippingRate[]> => {
  try {
    const { address, items } = request;

    // Calculate total weight
    let totalWeight = 0;
    for (const item of items) {
      totalWeight += item.weight * item.quantity;
    }

    // Calculate volumetric weight
    let totalVolume = 0;
    for (const item of items) {
      const itemVolume =
        item.dimensions.length *
        item.dimensions.width *
        item.dimensions.height *
        item.quantity;
      totalVolume += itemVolume;
    }

    // Volumetric weight calculation (simplified)
    const volumetricWeight = totalVolume / 5000; // 5000 is a common divisor for volumetric weight

    // Use the greater of actual weight and volumetric weight
    const chargeableWeight = Math.max(totalWeight, volumetricWeight);

    // Base rates depending on shipping destination (domestic vs international)
    const isDomestic = address.country === "US";

    // Create shipping rates based on weight and destination
    // These would normally come from a shipping API
    let rates: ShippingRate[] = [];

    if (isDomestic) {
      // Domestic shipping options
      rates = [
        {
          service_code: "standard",
          service_name: "Standard Shipping",
          rate: Math.round(5 + chargeableWeight * 0.5), // $5 base + $0.50 per weight unit
          estimated_days: 3,
        },
        {
          service_code: "expedited",
          service_name: "Expedited Shipping",
          rate: Math.round(12 + chargeableWeight * 0.75), // $12 base + $0.75 per weight unit
          estimated_days: 2,
        },
        {
          service_code: "express",
          service_name: "Express Shipping",
          rate: Math.round(20 + chargeableWeight * 1.2), // $20 base + $1.20 per weight unit
          estimated_days: 1,
        },
      ];
    } else {
      // International shipping options
      rates = [
        {
          service_code: "intl_standard",
          service_name: "International Standard",
          rate: Math.round(20 + chargeableWeight * 2), // $20 base + $2 per weight unit
          estimated_days: 10,
        },
        {
          service_code: "intl_express",
          service_name: "International Express",
          rate: Math.round(50 + chargeableWeight * 3), // $50 base + $3 per weight unit
          estimated_days: 5,
        },
      ];
    }

    // Convert cents to dollars for display
    return rates;
  } catch (error) {
    logger.error("Error calculating shipping rates:", error);
    throw new AppError("Failed to calculate shipping rates", 500);
  }
};

// Validate a shipping address
// In a production app, this would call an address validation API
export const validateAddress = async (
  address: ShippingAddress
): Promise<{ valid: boolean; suggestions?: ShippingAddress[] }> => {
  try {
    // Simple validation - check required fields
    if (
      !address.address_line1 ||
      !address.city ||
      !address.state ||
      !address.postal_code ||
      !address.country
    ) {
      return {
        valid: false,
        suggestions: [],
      };
    }

    // Simple postal code format check for US addresses
    if (
      address.country === "US" &&
      !/^\d{5}(-\d{4})?$/.test(address.postal_code)
    ) {
      const suggestion = {
        ...address,
        postal_code: address.postal_code.substring(0, 5),
      };
      return {
        valid: false,
        suggestions: [suggestion],
      };
    }

    // In a real app, you would call an address validation API here

    return { valid: true };
  } catch (error) {
    logger.error("Error validating address:", error);
    throw new AppError("Failed to validate address", 500);
  }
};

// Track a shipment
// In a real app, this would call a shipping carrier's tracking API
export const trackShipment = async (trackingNumber: string): Promise<any> => {
  try {
    // In a real app, you would call a shipping carrier's API
    // This is just a mock response

    // Return a fake tracking response
    return {
      tracking_number: trackingNumber,
      status: "in_transit",
      estimated_delivery: new Date(
        Date.now() + 3 * 24 * 60 * 60 * 1000
      ).toISOString(), // 3 days from now
      tracking_events: [
        {
          date: new Date().toISOString(),
          description: "Package has left the facility",
          location: "Distribution Center",
        },
        {
          date: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString(), // 12 hours ago
          description: "Package arrived at facility",
          location: "Distribution Center",
        },
        {
          date: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), // 24 hours ago
          description: "Shipment information received",
          location: "Shipper",
        },
      ],
    };
  } catch (error) {
    logger.error("Error tracking shipment:", error);
    throw new AppError("Failed to track shipment", 500);
  }
};

// Generate a shipping label
// In a real app, this would call a shipping API to generate a label
export const generateShippingLabel = async (
  orderId: string,
  shippingMethod: string,
  fromAddress: ShippingAddress,
  toAddress: ShippingAddress,
  items: ShippingItem[]
): Promise<{ trackingNumber: string; labelUrl: string }> => {
  try {
    // In a real app, you would call a shipping API
    // This is just a mock response

    // Generate a fake tracking number
    const trackingNumber = `TRK${Date.now().toString().substring(5)}`;

    // Return a fake label URL
    return {
      trackingNumber,
      labelUrl: `https://yourdomain.com/api/shipping/labels/${trackingNumber}.pdf`,
    };
  } catch (error) {
    logger.error("Error generating shipping label:", error);
    throw new AppError("Failed to generate shipping label", 500);
  }
};
</file>

<file path="src/services/user.service.ts">
import { getPaginatedData } from "@/utils/query-helper";
import { supabaseClient, getAdminClient } from "../config/supabase";
import { AppError } from "../utils/appError";
import { logger } from "../utils/logger";

// Interface for user profile data
export interface UserProfileDto {
  first_name: string;
  last_name: string;
  phone?: string;
}

// Interface for address data
export interface AddressDto {
  name: string;
  address_line1: string;
  address_line2?: string;
  city: string;
  state: string;
  postal_code: string;
  country: string;
  is_default?: boolean;
}

// Get user profile
export const getUserProfile = async (userId: string) => {
  try {
    const { data: user, error } = await supabaseClient
      .from("users")
      .select("id, email, first_name, last_name, phone, role, created_at")
      .eq("id", userId)
      .single();

    if (error) {
      logger.error(`Error getting user profile for ${userId}:`, error);
      throw new AppError("User not found", 404);
    }

    return user;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in getUserProfile for ${userId}:`, error);
    throw new AppError("Failed to get user profile", 500);
  }
};

// Update user profile
export const updateUserProfile = async (
  userId: string,
  profileData: UserProfileDto
) => {
  try {
    const { data: user, error } = await supabaseClient
      .from("users")
      .update({
        first_name: profileData.first_name,
        last_name: profileData.last_name,
        phone: profileData.phone,
        updated_at: new Date().toISOString(),
      })
      .eq("id", userId)
      .select(
        "id, email, first_name, last_name, phone, role, created_at, updated_at"
      )
      .single();

    if (error) {
      logger.error(`Error updating user profile for ${userId}:`, error);
      throw new AppError("Failed to update user profile", 500);
    }

    return user;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in updateUserProfile for ${userId}:`, error);
    throw new AppError("Failed to update user profile", 500);
  }
};

// Get user addresses
export const getUserAddresses = async (userId: string) => {
  try {
    const { data: addresses, error } = await supabaseClient
      .from("addresses")
      .select("*")
      .eq("user_id", userId)
      .order("is_default", { ascending: false })
      .order("created_at", { ascending: false });

    if (error) {
      logger.error(`Error getting addresses for user ${userId}:`, error);
      throw new AppError("Failed to get addresses", 500);
    }

    return addresses || [];
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in getUserAddresses for ${userId}:`, error);
    throw new AppError("Failed to get addresses", 500);
  }
};

// Add a new address
export const addUserAddress = async (
  userId: string,
  addressData: AddressDto
) => {
  try {
    // If this is the first address or is set as default, update other addresses
    if (addressData.is_default) {
      const { error: updateError } = await supabaseClient
        .from("addresses")
        .update({ is_default: false })
        .eq("user_id", userId)
        .eq("is_default", true);

      if (updateError) {
        logger.error(
          `Error updating default addresses for user ${userId}:`,
          updateError
        );
        // Continue anyway
      }
    }

    // Check if this is the first address for the user
    const {
      data,
      error: countError,
      count,
    } = await supabaseClient
      .from("addresses")
      .select("id", { count: "exact", head: true })
      .eq("user_id", userId);

    if (countError) {
      logger.error(`Error counting addresses for user ${userId}:`, countError);
      // Continue anyway
    }

    // If this is the first address, make it default regardless of input
    const isDefault = count === 0 ? true : addressData.is_default;

    // Add the new address
    const { data: address, error } = await supabaseClient
      .from("addresses")
      .insert([
        {
          user_id: userId,
          name: addressData.name,
          address_line1: addressData.address_line1,
          address_line2: addressData.address_line2 || null,
          city: addressData.city,
          state: addressData.state,
          postal_code: addressData.postal_code,
          country: addressData.country,
          is_default: isDefault,
        },
      ])
      .select()
      .single();

    if (error) {
      logger.error(`Error adding address for user ${userId}:`, error);
      throw new AppError("Failed to add address", 500);
    }

    return address;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in addUserAddress for ${userId}:`, error);
    throw new AppError("Failed to add address", 500);
  }
};

// Update an address
export const updateUserAddress = async (
  userId: string,
  addressId: string,
  addressData: Partial<AddressDto>
) => {
  try {
    // Check if address exists and belongs to user
    const { data: existingAddress, error: checkError } = await supabaseClient
      .from("addresses")
      .select("id, is_default")
      .eq("id", addressId)
      .eq("user_id", userId)
      .single();

    if (checkError || !existingAddress) {
      logger.error(
        `Address ${addressId} not found for user ${userId}:`,
        checkError
      );
      throw new AppError("Address not found", 404);
    }

    // If setting as default, update other addresses
    if (addressData.is_default && !existingAddress.is_default) {
      const { error: updateError } = await supabaseClient
        .from("addresses")
        .update({ is_default: false })
        .eq("user_id", userId)
        .eq("is_default", true);

      if (updateError) {
        logger.error(
          `Error updating default addresses for user ${userId}:`,
          updateError
        );
        // Continue anyway
      }
    }

    // Update the address
    const { data: address, error } = await supabaseClient
      .from("addresses")
      .update({
        name: addressData.name,
        address_line1: addressData.address_line1,
        address_line2: addressData.address_line2,
        city: addressData.city,
        state: addressData.state,
        postal_code: addressData.postal_code,
        country: addressData.country,
        is_default: addressData.is_default,
        updated_at: new Date().toISOString(),
      })
      .eq("id", addressId)
      .eq("user_id", userId)
      .select()
      .single();

    if (error) {
      logger.error(
        `Error updating address ${addressId} for user ${userId}:`,
        error
      );
      throw new AppError("Failed to update address", 500);
    }

    return address;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(
      `Unexpected error in updateUserAddress for ${userId}, ${addressId}:`,
      error
    );
    throw new AppError("Failed to update address", 500);
  }
};

// Delete an address
export const deleteUserAddress = async (userId: string, addressId: string) => {
  try {
    // Check if address exists and belongs to user
    const { data: existingAddress, error: checkError } = await supabaseClient
      .from("addresses")
      .select("id, is_default")
      .eq("id", addressId)
      .eq("user_id", userId)
      .single();

    if (checkError || !existingAddress) {
      logger.error(
        `Address ${addressId} not found for user ${userId}:`,
        checkError
      );
      throw new AppError("Address not found", 404);
    }

    // Delete the address
    const { error } = await supabaseClient
      .from("addresses")
      .delete()
      .eq("id", addressId)
      .eq("user_id", userId);

    if (error) {
      logger.error(
        `Error deleting address ${addressId} for user ${userId}:`,
        error
      );
      throw new AppError("Failed to delete address", 500);
    }

    // If deleted address was default, set a new default
    if (existingAddress.is_default) {
      const { data: addresses, error: fetchError } = await supabaseClient
        .from("addresses")
        .select("id")
        .eq("user_id", userId)
        .order("created_at", { ascending: false })
        .limit(1);

      if (!fetchError && addresses && addresses.length > 0) {
        // Set the first address as default
        const { error: updateError } = await supabaseClient
          .from("addresses")
          .update({ is_default: true })
          .eq("id", addresses[0].id)
          .eq("user_id", userId);

        if (updateError) {
          logger.error(
            `Error setting new default address for user ${userId}:`,
            updateError
          );
          // Not critical, continue
        }
      }
    }

    return { success: true };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(
      `Unexpected error in deleteUserAddress for ${userId}, ${addressId}:`,
      error
    );
    throw new AppError("Failed to delete address", 500);
  }
};

// Admin: Get all users
export const getAllUsers = async (page = 1, limit = 20) => {
  try {
    const adminClient = getAdminClient();

    // Use the utility function to get paginated data
    const result = await getPaginatedData({
      client: adminClient,
      table: "users",
      options: {
        page,
        limit,
        sortBy: "created_at",
        sortOrder: "desc",
      },
      select:
        "id, email, first_name, last_name, phone, role, created_at, updated_at",
    });

    return {
      users: result.data,
      pagination: result.pagination,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error("Unexpected error in getAllUsers:", error);
    throw new AppError("Failed to get users", 500);
  }
};
// Admin: Get user details
export const getUserDetails = async (userId: string) => {
  try {
    const adminClient = getAdminClient();

    // Get user details
    const { data: user, error } = await adminClient
      .from("users")
      .select(
        `
        id, 
        email, 
        first_name, 
        last_name, 
        phone, 
        role, 
        created_at, 
        updated_at,
        addresses (*)
      `
      )
      .eq("id", userId)
      .single();

    if (error) {
      logger.error(`Error getting user details for ${userId}:`, error);
      throw new AppError("User not found", 404);
    }

    return user;
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in getUserDetails for ${userId}:`, error);
    throw new AppError("Failed to get user details", 500);
  }
};
</file>

<file path="src/types/api.ts">
export interface ProductImage {
  url: string;
  alt_text: string;
  is_primary: boolean;
}

export interface ProductWithImages {
  id: string;
  name: string;
  price: number;
  compare_at_price: number | null;
  sku: string;
  weight: number;
  dimensions: {
    length: number;
    width: number;
    height: number;
  };
  inventory_quantity: number;
  product_images: ProductImage[];
}

export interface CartItemWithProduct {
  id: string;
  quantity: number;
  created_at: string;
  updated_at: string;
  products: ProductWithImages;
}

export interface CartWithItems {
  cart: {
    id: string;
    user_id: string | null;
    session_id: string | null;
    created_at: string;
    updated_at: string;
  };
  items: CartItemWithProduct[];
  summary: {
    subtotal: number;
    totalItems: number;
  };
}
</file>

<file path="src/types/database.types.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      addresses: {
        Row: {
          address_line1: string
          address_line2: string | null
          city: string
          country: string
          created_at: string | null
          id: string
          is_default: boolean
          name: string
          postal_code: string
          state: string
          updated_at: string | null
          user_id: string
        }
        Insert: {
          address_line1: string
          address_line2?: string | null
          city: string
          country: string
          created_at?: string | null
          id?: string
          is_default?: boolean
          name: string
          postal_code: string
          state: string
          updated_at?: string | null
          user_id: string
        }
        Update: {
          address_line1?: string
          address_line2?: string | null
          city?: string
          country?: string
          created_at?: string | null
          id?: string
          is_default?: boolean
          name?: string
          postal_code?: string
          state?: string
          updated_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "addresses_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      cart_items: {
        Row: {
          cart_id: string
          created_at: string | null
          id: string
          product_id: string
          quantity: number
          updated_at: string | null
        }
        Insert: {
          cart_id: string
          created_at?: string | null
          id?: string
          product_id: string
          quantity: number
          updated_at?: string | null
        }
        Update: {
          cart_id?: string
          created_at?: string | null
          id?: string
          product_id?: string
          quantity?: number
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "cart_items_cart_id_fkey"
            columns: ["cart_id"]
            isOneToOne: false
            referencedRelation: "carts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "cart_items_product_id_fkey"
            columns: ["product_id"]
            isOneToOne: false
            referencedRelation: "products"
            referencedColumns: ["id"]
          },
        ]
      }
      carts: {
        Row: {
          created_at: string | null
          id: string
          session_id: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          session_id?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          session_id?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "carts_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      categories: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          name: string
          parent_id: string | null
          slug: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          name: string
          parent_id?: string | null
          slug: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          name?: string
          parent_id?: string | null
          slug?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "categories_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "categories"
            referencedColumns: ["id"]
          },
        ]
      }
      order_items: {
        Row: {
          created_at: string | null
          id: string
          order_id: string
          product_id: string
          quantity: number
          total_price: number
          unit_price: number
        }
        Insert: {
          created_at?: string | null
          id?: string
          order_id: string
          product_id: string
          quantity: number
          total_price: number
          unit_price: number
        }
        Update: {
          created_at?: string | null
          id?: string
          order_id?: string
          product_id?: string
          quantity?: number
          total_price?: number
          unit_price?: number
        }
        Relationships: [
          {
            foreignKeyName: "order_items_order_id_fkey"
            columns: ["order_id"]
            isOneToOne: false
            referencedRelation: "orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "order_items_product_id_fkey"
            columns: ["product_id"]
            isOneToOne: false
            referencedRelation: "products"
            referencedColumns: ["id"]
          },
        ]
      }
      orders: {
        Row: {
          billing_address_id: string
          created_at: string | null
          discount_amount: number
          id: string
          notes: string | null
          shipping_address_id: string
          shipping_cost: number
          shipping_method: string
          status: string
          stripe_payment_intent_id: string | null
          subtotal: number
          tax: number
          total_amount: number
          tracking_number: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          billing_address_id: string
          created_at?: string | null
          discount_amount?: number
          id?: string
          notes?: string | null
          shipping_address_id: string
          shipping_cost: number
          shipping_method: string
          status?: string
          stripe_payment_intent_id?: string | null
          subtotal: number
          tax: number
          total_amount: number
          tracking_number?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          billing_address_id?: string
          created_at?: string | null
          discount_amount?: number
          id?: string
          notes?: string | null
          shipping_address_id?: string
          shipping_cost?: number
          shipping_method?: string
          status?: string
          stripe_payment_intent_id?: string | null
          subtotal?: number
          tax?: number
          total_amount?: number
          tracking_number?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "orders_billing_address_id_fkey"
            columns: ["billing_address_id"]
            isOneToOne: false
            referencedRelation: "addresses"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "orders_shipping_address_id_fkey"
            columns: ["shipping_address_id"]
            isOneToOne: false
            referencedRelation: "addresses"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "orders_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      product_images: {
        Row: {
          alt_text: string
          created_at: string | null
          id: string
          is_primary: boolean
          position: number
          product_id: string
          url: string
        }
        Insert: {
          alt_text: string
          created_at?: string | null
          id?: string
          is_primary?: boolean
          position: number
          product_id: string
          url: string
        }
        Update: {
          alt_text?: string
          created_at?: string | null
          id?: string
          is_primary?: boolean
          position?: number
          product_id?: string
          url?: string
        }
        Relationships: [
          {
            foreignKeyName: "product_images_product_id_fkey"
            columns: ["product_id"]
            isOneToOne: false
            referencedRelation: "products"
            referencedColumns: ["id"]
          },
        ]
      }
      products: {
        Row: {
          barcode: string | null
          category_id: string
          compare_at_price: number | null
          cost_price: number
          created_at: string | null
          description: string
          dimensions: Json
          id: string
          inventory_quantity: number
          is_active: boolean
          name: string
          price: number
          sku: string
          updated_at: string | null
          weight: number
        }
        Insert: {
          barcode?: string | null
          category_id: string
          compare_at_price?: number | null
          cost_price: number
          created_at?: string | null
          description: string
          dimensions: Json
          id?: string
          inventory_quantity?: number
          is_active?: boolean
          name: string
          price: number
          sku: string
          updated_at?: string | null
          weight: number
        }
        Update: {
          barcode?: string | null
          category_id?: string
          compare_at_price?: number | null
          cost_price?: number
          created_at?: string | null
          description?: string
          dimensions?: Json
          id?: string
          inventory_quantity?: number
          is_active?: boolean
          name?: string
          price?: number
          sku?: string
          updated_at?: string | null
          weight?: number
        }
        Relationships: [
          {
            foreignKeyName: "products_category_id_fkey"
            columns: ["category_id"]
            isOneToOne: false
            referencedRelation: "categories"
            referencedColumns: ["id"]
          },
        ]
      }
      users: {
        Row: {
          created_at: string | null
          email: string
          first_name: string
          id: string
          last_name: string
          phone: string | null
          role: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          email: string
          first_name: string
          id: string
          last_name: string
          phone?: string | null
          role?: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          email?: string
          first_name?: string
          id?: string
          last_name?: string
          phone?: string | null
          role?: string
          updated_at?: string | null
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      increment_inventory: {
        Args: {
          p_product_id: string
          p_quantity: number
        }
        Returns: undefined
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type PublicSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &
        PublicSchema["Views"])
    ? (PublicSchema["Tables"] &
        PublicSchema["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof PublicSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]
    ? PublicSchema["Enums"][PublicEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof PublicSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof PublicSchema["CompositeTypes"]
    ? PublicSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never
</file>

<file path="src/utils/validators/auth.validator.ts">
import { body } from "express-validator";

// Validation rules for user registration
export const registerValidator = [
  body("email")
    .isEmail()
    .withMessage("Please provide a valid email address")
    .normalizeEmail(),
  body("password")
    .isLength({ min: 8 })
    .withMessage("Password must be at least 8 characters long")
    .matches(/\d/)
    .withMessage("Password must contain at least one number")
    .matches(/[a-z]/)
    .withMessage("Password must contain at least one lowercase letter")
    .matches(/[A-Z]/)
    .withMessage("Password must contain at least one uppercase letter"),
  body("first_name")
    .trim()
    .notEmpty()
    .withMessage("First name is required")
    .isLength({ max: 50 })
    .withMessage("First name must be at most 50 characters"),
  body("last_name")
    .trim()
    .notEmpty()
    .withMessage("Last name is required")
    .isLength({ max: 50 })
    .withMessage("Last name must be at most 50 characters"),
  body("phone")
    .optional()
    .isMobilePhone("any")
    .withMessage("Please provide a valid phone number"),
];

// Validation rules for user login
export const loginValidator = [
  body("email")
    .isEmail()
    .withMessage("Please provide a valid email address")
    .normalizeEmail(),
  body("password").notEmpty().withMessage("Password is required"),
];

// Validation rules for forgot password request
export const forgotPasswordValidator = [
  body("email")
    .isEmail()
    .withMessage("Please provide a valid email address")
    .normalizeEmail(),
];

// Validation rules for password reset
export const resetPasswordValidator = [
  body("token").notEmpty().withMessage("Token is required"),
  body("password")
    .isLength({ min: 8 })
    .withMessage("Password must be at least 8 characters long")
    .matches(/\d/)
    .withMessage("Password must contain at least one number")
    .matches(/[a-z]/)
    .withMessage("Password must contain at least one lowercase letter")
    .matches(/[A-Z]/)
    .withMessage("Password must contain at least one uppercase letter"),
];
</file>

<file path="src/utils/validators/cart.validator.ts">
import { body } from "express-validator";

// Validation rules for adding item to cart
export const addToCartValidator = [
  body("product_id").notEmpty().withMessage("Product ID is required"),

  body("quantity")
    .isInt({ min: 1 })
    .withMessage("Quantity must be a positive integer"),
];

// Validation rules for updating cart item
export const updateCartItemValidator = [
  body("quantity")
    .isInt({ min: 1 })
    .withMessage("Quantity must be a positive integer"),
];
</file>

<file path="src/utils/validators/order.validator.ts">
import { body } from "express-validator";

// Validation rules for updating order status
export const updateOrderStatusValidator = [
  body("status")
    .notEmpty()
    .withMessage("Status is required")
    .isIn([
      "pending",
      "paid",
      "processing",
      "shipped",
      "delivered",
      "cancelled",
      "refunded",
    ])
    .withMessage("Invalid status value"),

  body("tracking_number")
    .optional()
    .isString()
    .withMessage("Tracking number must be a string")
    .isLength({ max: 100 })
    .withMessage("Tracking number must be at most 100 characters"),
];
</file>

<file path="src/utils/validators/payment.validator.ts">
import { body } from "express-validator";

// Validation rules for creating a payment intent
export const createPaymentIntentValidator = [
  body("cart_id").notEmpty().withMessage("Cart ID is required"),

  body("shipping_address_id")
    .notEmpty()
    .withMessage("Shipping address ID is required"),

  body("billing_address_id")
    .notEmpty()
    .withMessage("Billing address ID is required"),

  body("shipping_method").notEmpty().withMessage("Shipping method is required"),

  body("customer_id").optional(),

  body("metadata")
    .optional()
    .isObject()
    .withMessage("Metadata must be an object"),
];
</file>

<file path="src/utils/validators/product.validator.ts">
import { body } from "express-validator";

// Validation rules for creating a product
export const createProductValidator = [
  body("name")
    .trim()
    .notEmpty()
    .withMessage("Product name is required")
    .isLength({ max: 200 })
    .withMessage("Product name must be at most 200 characters"),

  body("description")
    .trim()
    .notEmpty()
    .withMessage("Product description is required"),

  body("price")
    .isNumeric()
    .withMessage("Price must be a number")
    .custom((value) => value >= 0)
    .withMessage("Price cannot be negative"),

  body("compare_at_price")
    .optional()
    .isNumeric()
    .withMessage("Compare at price must be a number")
    .custom((value) => value >= 0)
    .withMessage("Compare at price cannot be negative"),

  body("cost_price")
    .isNumeric()
    .withMessage("Cost price must be a number")
    .custom((value) => value >= 0)
    .withMessage("Cost price cannot be negative"),

  body("sku")
    .trim()
    .notEmpty()
    .withMessage("SKU is required")
    .isLength({ max: 50 })
    .withMessage("SKU must be at most 50 characters"),

  body("barcode")
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage("Barcode must be at most 50 characters"),

  body("weight")
    .isNumeric()
    .withMessage("Weight must be a number")
    .custom((value) => value > 0)
    .withMessage("Weight must be greater than 0"),

  body("dimensions").isObject().withMessage("Dimensions must be an object"),

  body("dimensions.length")
    .isNumeric()
    .withMessage("Length must be a number")
    .custom((value) => value > 0)
    .withMessage("Length must be greater than 0"),

  body("dimensions.width")
    .isNumeric()
    .withMessage("Width must be a number")
    .custom((value) => value > 0)
    .withMessage("Width must be greater than 0"),

  body("dimensions.height")
    .isNumeric()
    .withMessage("Height must be a number")
    .custom((value) => value > 0)
    .withMessage("Height must be greater than 0"),

  body("inventory_quantity")
    .isInt()
    .withMessage("Inventory quantity must be an integer")
    .custom((value) => value >= 0)
    .withMessage("Inventory quantity cannot be negative"),

  body("is_active")
    .optional()
    .isBoolean()
    .withMessage("Is active must be a boolean"),

  body("category_id").notEmpty().withMessage("Category ID is required"),

  body("images").optional().isArray().withMessage("Images must be an array"),

  body("images.*.url")
    .notEmpty()
    .withMessage("Image URL is required")
    .isURL()
    .withMessage("Image URL must be a valid URL"),

  body("images.*.alt_text")
    .notEmpty()
    .withMessage("Image alt text is required"),

  body("images.*.position")
    .isInt()
    .withMessage("Image position must be an integer"),

  body("images.*.is_primary")
    .optional()
    .isBoolean()
    .withMessage("Is primary must be a boolean"),
];

// Validation rules for updating a product
export const updateProductValidator = [
  body("name")
    .optional()
    .trim()
    .notEmpty()
    .withMessage("Product name cannot be empty")
    .isLength({ max: 200 })
    .withMessage("Product name must be at most 200 characters"),

  body("description")
    .optional()
    .trim()
    .notEmpty()
    .withMessage("Product description cannot be empty"),

  body("price")
    .optional()
    .isNumeric()
    .withMessage("Price must be a number")
    .custom((value) => value >= 0)
    .withMessage("Price cannot be negative"),

  body("compare_at_price")
    .optional()
    .isNumeric()
    .withMessage("Compare at price must be a number")
    .custom((value) => value >= 0)
    .withMessage("Compare at price cannot be negative"),

  body("cost_price")
    .optional()
    .isNumeric()
    .withMessage("Cost price must be a number")
    .custom((value) => value >= 0)
    .withMessage("Cost price cannot be negative"),

  body("sku")
    .optional()
    .trim()
    .notEmpty()
    .withMessage("SKU cannot be empty")
    .isLength({ max: 50 })
    .withMessage("SKU must be at most 50 characters"),

  body("barcode")
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage("Barcode must be at most 50 characters"),

  body("weight")
    .optional()
    .isNumeric()
    .withMessage("Weight must be a number")
    .custom((value) => value > 0)
    .withMessage("Weight must be greater than 0"),

  body("dimensions")
    .optional()
    .isObject()
    .withMessage("Dimensions must be an object"),

  body("dimensions.length")
    .optional()
    .isNumeric()
    .withMessage("Length must be a number")
    .custom((value) => value > 0)
    .withMessage("Length must be greater than 0"),

  body("dimensions.width")
    .optional()
    .isNumeric()
    .withMessage("Width must be a number")
    .custom((value) => value > 0)
    .withMessage("Width must be greater than 0"),

  body("dimensions.height")
    .optional()
    .isNumeric()
    .withMessage("Height must be a number")
    .custom((value) => value > 0)
    .withMessage("Height must be greater than 0"),

  body("inventory_quantity")
    .optional()
    .isInt()
    .withMessage("Inventory quantity must be an integer")
    .custom((value) => value >= 0)
    .withMessage("Inventory quantity cannot be negative"),

  body("is_active")
    .optional()
    .isBoolean()
    .withMessage("Is active must be a boolean"),

  body("category_id")
    .optional()
    .notEmpty()
    .withMessage("Category ID cannot be empty"),

  body("images").optional().isArray().withMessage("Images must be an array"),

  body("images.*.url")
    .optional()
    .notEmpty()
    .withMessage("Image URL cannot be empty")
    .isURL()
    .withMessage("Image URL must be a valid URL"),

  body("images.*.alt_text")
    .optional()
    .notEmpty()
    .withMessage("Image alt text cannot be empty"),

  body("images.*.position")
    .optional()
    .isInt()
    .withMessage("Image position must be an integer"),

  body("images.*.is_primary")
    .optional()
    .isBoolean()
    .withMessage("Is primary must be a boolean"),
];
</file>

<file path="src/utils/validators/shipping.validator.ts">
import { body } from "express-validator";

// Validation rules for calculating shipping rates
export const shippingRateValidator = [
  body("address_id").notEmpty().withMessage("Shipping address ID is required"),

  body("cart_id").notEmpty().withMessage("Cart ID is required"),
];

// Validation rules for validating a shipping address
export const addressValidator = [
  body("address_line1")
    .notEmpty()
    .withMessage("Address line 1 is required")
    .isLength({ max: 100 })
    .withMessage("Address line 1 must be at most 100 characters"),

  body("address_line2")
    .optional()
    .isLength({ max: 100 })
    .withMessage("Address line 2 must be at most 100 characters"),

  body("city")
    .notEmpty()
    .withMessage("City is required")
    .isLength({ max: 50 })
    .withMessage("City must be at most 50 characters"),

  body("state")
    .notEmpty()
    .withMessage("State is required")
    .isLength({ max: 50 })
    .withMessage("State must be at most 50 characters"),

  body("postal_code")
    .notEmpty()
    .withMessage("Postal code is required")
    .isLength({ max: 20 })
    .withMessage("Postal code must be at most 20 characters"),

  body("country")
    .notEmpty()
    .withMessage("Country is required")
    .isLength({ max: 50 })
    .withMessage("Country must be at most 50 characters"),
];
</file>

<file path="src/utils/validators/user.validator.ts">
import { body } from "express-validator";

// Validation rules for updating user profile
export const updateProfileValidator = [
  body("first_name")
    .notEmpty()
    .withMessage("First name is required")
    .isLength({ max: 50 })
    .withMessage("First name must be at most 50 characters"),

  body("last_name")
    .notEmpty()
    .withMessage("Last name is required")
    .isLength({ max: 50 })
    .withMessage("Last name must be at most 50 characters"),

  body("phone")
    .optional()
    .isMobilePhone("any")
    .withMessage("Please provide a valid phone number"),
];

// Validation rules for adding/updating address
export const addressValidator = [
  body("name")
    .notEmpty()
    .withMessage("Address name is required")
    .isLength({ max: 100 })
    .withMessage("Address name must be at most 100 characters"),

  body("address_line1")
    .notEmpty()
    .withMessage("Address line 1 is required")
    .isLength({ max: 100 })
    .withMessage("Address line 1 must be at most 100 characters"),

  body("address_line2")
    .optional()
    .isLength({ max: 100 })
    .withMessage("Address line 2 must be at most 100 characters"),

  body("city")
    .notEmpty()
    .withMessage("City is required")
    .isLength({ max: 50 })
    .withMessage("City must be at most 50 characters"),

  body("state")
    .notEmpty()
    .withMessage("State is required")
    .isLength({ max: 50 })
    .withMessage("State must be at most 50 characters"),

  body("postal_code")
    .notEmpty()
    .withMessage("Postal code is required")
    .isLength({ max: 20 })
    .withMessage("Postal code must be at most 20 characters"),

  body("country")
    .notEmpty()
    .withMessage("Country is required")
    .isLength({ max: 50 })
    .withMessage("Country must be at most 50 characters"),

  body("is_default")
    .optional()
    .isBoolean()
    .withMessage("Is default must be a boolean"),
];
</file>

<file path="src/utils/appError.ts">
export class AppError extends Error {
  statusCode: number;
  status: string;
  isOperational: boolean;
  errors?: any[];

  constructor(message: string, statusCode: number, errors?: any[]) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;
    this.errors = errors;
    Error.captureStackTrace(this, this.constructor);
  }
}

// 400 - Bad Request
// 401 - Unauthorized
// 403 - Forbidden
// 404 - Not Found
// 500 - Internal Server Error
</file>

<file path="src/utils/logger.ts">
import { Request, Response, NextFunction } from "express";

// Simple logger implementation - in production you might want to use a library like Winston
const logLevels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

type LogLevel = keyof typeof logLevels;

const getLogLevel = (): LogLevel => {
  const env = process.env.NODE_ENV || "development";
  const level =
    (process.env.LOG_LEVEL as LogLevel) ||
    (env === "development" ? "debug" : "info");
  return level;
};

const shouldLog = (level: LogLevel): boolean => {
  const currentLevel = getLogLevel();
  return logLevels[level] <= logLevels[currentLevel];
};

const formatLog = (level: LogLevel, message: string, meta?: any): string => {
  const timestamp = new Date().toISOString();
  let logMessage = `${timestamp} [${level.toUpperCase()}] ${message}`;

  if (meta) {
    try {
      const metaString = typeof meta === "object" ? JSON.stringify(meta) : meta;
      logMessage += ` - ${metaString}`;
    } catch (error) {
      logMessage += ` - [Circular or Non-Serializable Data]`;
    }
  }

  return logMessage;
};

export const logger = {
  error: (message: string, meta?: any) => {
    if (shouldLog("error")) {
      console.error(formatLog("error", message, meta));
    }
  },

  warn: (message: string, meta?: any) => {
    if (shouldLog("warn")) {
      console.warn(formatLog("warn", message, meta));
    }
  },

  info: (message: string, meta?: any) => {
    if (shouldLog("info")) {
      console.info(formatLog("info", message, meta));
    }
  },

  http: (message: string, meta?: any) => {
    if (shouldLog("http")) {
      console.log(formatLog("http", message, meta));
    }
  },

  debug: (message: string, meta?: any) => {
    if (shouldLog("debug")) {
      console.debug(formatLog("debug", message, meta));
    }
  },
};

// Middleware for logging HTTP requests
export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;
    const message = `${req.method} ${req.originalUrl} ${res.statusCode} - ${duration}ms`;

    // Log request details based on status code
    if (res.statusCode >= 500) {
      logger.error(message, {
        body: req.body,
        query: req.query,
        params: req.params,
      });
    } else if (res.statusCode >= 400) {
      logger.warn(message, {
        body: req.body,
        query: req.query,
        params: req.params,
      });
    } else {
      logger.http(message);
    }
  });

  next();
};
</file>

<file path="src/utils/query-helper.ts">
import { SupabaseClient } from "@supabase/supabase-js";
import { logger } from "./logger";
import { AppError } from "./appError";

/**
 * Type for pagination parameters
 */
export interface PaginationOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: "asc" | "desc";
}

/**
 * Type for pagination response
 */
export interface PaginationResponse<T> {
  data: T[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    pages: number;
  };
}

/**
 * Get paginated data with count from Supabase
 *
 * @param client Supabase client instance
 * @param table Table name
 * @param options Pagination options
 * @param select Select query (can include joins)
 * @param applyFilters Function to apply filters to both count and data queries
 * @returns Paginated data with count
 */
export async function getPaginatedData<T = any>({
  client,
  table,
  options = {},
  select = "*",
  applyFilters = (query) => query,
}: {
  client: SupabaseClient;
  table: string;
  options?: PaginationOptions;
  select?: string;
  applyFilters?: (query: any) => any;
}): Promise<PaginationResponse<T>> {
  try {
    const {
      page = 1,
      limit = 20,
      sortBy = "created_at",
      sortOrder = "desc",
    } = options;

    // Calculate offset for pagination
    const offset = (page - 1) * limit;

    // Get total count with same filters
    const countQuery = applyFilters(
      client.from(table).select("*", { count: "exact", head: true })
    );

    const { count, error: countError } = await countQuery;

    if (countError) {
      logger.error(`Error counting ${table}:`, countError);
      throw new AppError(`Failed to get ${table} count`, 500);
    }

    // Get data with same filters plus pagination
    let dataQuery = applyFilters(client.from(table).select(select));

    // Apply sorting and pagination
    dataQuery = dataQuery
      .order(sortBy, { ascending: sortOrder === "asc" })
      .range(offset, offset + limit - 1);

    const { data, error } = await dataQuery;

    if (error) {
      logger.error(`Error getting ${table}:`, error);
      throw new AppError(`Failed to get ${table}`, 500);
    }

    return {
      data: data || [],
      pagination: {
        total: count || 0,
        page,
        limit,
        pages: Math.ceil((count || 0) / limit),
      },
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    logger.error(`Unexpected error in getPaginatedData for ${table}:`, error);
    throw new AppError(`Failed to get ${table}`, 500);
  }
}

/**
 * Create filter conditions for a query based on an object of filters
 *
 * @param filters Object with field-value pairs for filtering
 * @returns Function that applies filters to a query
 */
export function createFilters(filters: Record<string, any> = {}) {
  return (query: any) => {
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        query = query.eq(key, value);
      }
    });
    return query;
  };
}

/**
 * Apply a filter only if condition is true
 *
 * @param query Supabase query
 * @param condition Boolean condition
 * @param filterFn Function to apply filter
 * @returns Modified query
 */
export function applyFilterIf<T>(
  query: T,
  condition: boolean,
  filterFn: (q: T) => T
): T {
  return condition ? filterFn(query) : query;
}
</file>

<file path="src/app.ts">
import express, {
  Request,
  Response,
  NextFunction,
  ErrorRequestHandler,
} from "express";
import cors from "cors";
import helmet from "helmet";
import cookieParser from "cookie-parser";
import csurf from "csurf";
//routes
import authRoutes from "./routes/auth.routes";
import productRoutes from "./routes/product.routes";
import userRoutes from "./routes/user.routes";
import cartRoutes from "./routes/cart.routes";
import orderRoutes from "./routes/order.routes";
import adminRoutes from "./routes/admin.routes";
import shippingRoutes from "./routes/shipping.routes";

import { AppError } from "./utils/appError";
import { requestLogger } from "./utils/logger";
import { errorHandler } from "./middlewares/errorHandler";
import paymentRoutes from "./routes/payment.routes";
import { handleStripeWebhookRequest } from "./controllers/webhook.controller";

const app = express();

// Middleware
app.use(helmet());

// Configure CORS
const corsOptions = {
  origin: process.env.CORS_ORIGIN?.split(",") || "http://localhost:3000",
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
  credentials: true,
};
app.use(cors(corsOptions));

app.post(
  "/api/payment/webhook",
  express.raw({ type: "application/json" }),
  handleStripeWebhookRequest
);

// Body parsing middleware
app.use(express.json({ limit: "10kb" }));
app.use(express.urlencoded({ extended: true, limit: "10kb" }));

// Request logging
app.use(requestLogger);

// Health check endpoint
app.get("/health", (req: Request, res: Response) => {
  res.status(200).json({ status: "ok" });
});

app.use(cookieParser());

if (process.env.NODE_ENV === "production") {
  app.use(csurf({ cookie: { httpOnly: true, secure: true } }));

  // Error handler for CSRF token errors
  const csrfErrorHandler: ErrorRequestHandler = (err, req, res, next): void => {
    if (
      err &&
      typeof err === "object" &&
      "code" in err &&
      err.code === "EBADCSRFTOKEN"
    ) {
      res.status(403).json({
        status: "error",
        message: "Invalid CSRF token",
      });
      return;
    }
    next(err);
  };

  app.use(csrfErrorHandler);
}

// API routes
app.use("/api/auth", authRoutes);
app.use("/api/products", productRoutes);
app.use("/api/users", userRoutes);
app.use("/api/cart", cartRoutes);
app.use("/api/orders", orderRoutes);
app.use("/api/admin", adminRoutes);
app.use("/api/shipping", shippingRoutes);
app.use("/api/payment", paymentRoutes);

// 404 handler
app.all("*", (req: Request, res: Response, next: NextFunction) => {
  next(new AppError(`Cannot find ${req.originalUrl} on this server.`, 404));
});

// Global error handler
app.use(errorHandler);

export default app;
</file>

<file path="src/server.ts">
import dotenv from "dotenv";
dotenv.config();

import app from "./app";
import { logger } from "./utils/logger";

const PORT = process.env.PORT || 3001;

// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
  logger.error("Uncaught Exception:", error);
  process.exit(1);
});

// Start the server
const server = app.listen(PORT, () => {
  logger.info(
    `Server listening on port ${PORT} in ${process.env.NODE_ENV} mode`
  );
});

// Handle unhandled promise rejections
process.on("unhandledRejection", (error) => {
  logger.error("Unhandled Rejection:", error);
  server.close(() => process.exit(1));
});

// Handle server shutdown gracefully
process.on("SIGTERM", () => {
  logger.info("SIGTERM received, shutting down gracefully");
  server.close(() => {
    logger.info("Process terminated");
  });
});
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ecommerce-server"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"
# Specifies static files to be bundled with the function. Supports glob patterns.
# For example, if you want to serve static HTML pages in your function:
# static_files = [ "./functions/MY_FUNCTION_NAME/*.html" ]

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path=".env.example">
# Server Configuration
NODE_ENV=development
PORT=3001
API_URL=http://localhost:3001
FRONTEND_URL=http://localhost:3000

# JWT
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=7d

# Supabase Configuration
SUPABASE_URL=your_supabase_url
SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key

# Stripe Configuration
STRIPE_SECRET_KEY=your_stripe_secret_key
STRIPE_WEBHOOK_SECRET=your_stripe_webhook_secret

# Shipping API (e.g., ShipEngine, EasyPost, etc.)
SHIPPING_API_KEY=your_shipping_api_key
SHIPPING_API_URL=your_shipping_api_url

# Logging
LOG_LEVEL=info

# Security
CORS_ORIGIN=http://localhost:3000,https://yourdomain.com
RATE_LIMIT_WINDOW_MS=15*60*1000
RATE_LIMIT_MAX=100
</file>

<file path=".gitignore">
.env
node_modules
package-lock.json
</file>

<file path="db.sql">
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table
CREATE TABLE users (
  id UUID PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  phone TEXT,
  role TEXT NOT NULL DEFAULT 'customer',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Addresses table
CREATE TABLE addresses (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  address_line1 TEXT NOT NULL,
  address_line2 TEXT,
  city TEXT NOT NULL,
  state TEXT NOT NULL,
  postal_code TEXT NOT NULL,
  country TEXT NOT NULL,
  is_default BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Categories table
CREATE TABLE categories (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  description TEXT,
  parent_id UUID REFERENCES categories(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Products table
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  price DECIMAL(10, 2) NOT NULL,
  compare_at_price DECIMAL(10, 2),
  cost_price DECIMAL(10, 2) NOT NULL,
  sku TEXT UNIQUE NOT NULL,
  barcode TEXT,
  weight DECIMAL(10, 2) NOT NULL,
  dimensions JSONB NOT NULL,
  inventory_quantity INTEGER NOT NULL DEFAULT 0,
  is_active BOOLEAN NOT NULL DEFAULT true,
  category_id UUID NOT NULL REFERENCES categories(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Product images table
CREATE TABLE product_images (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  url TEXT NOT NULL,
  alt_text TEXT NOT NULL,
  position INTEGER NOT NULL,
  is_primary BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Carts table
CREATE TABLE carts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  session_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Cart items table
CREATE TABLE cart_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  cart_id UUID NOT NULL REFERENCES carts(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES products(id),
  quantity INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(cart_id, product_id)
);

-- Orders table
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  status TEXT NOT NULL DEFAULT 'pending',
  total_amount DECIMAL(10, 2) NOT NULL,
  subtotal DECIMAL(10, 2) NOT NULL,
  tax DECIMAL(10, 2) NOT NULL,
  shipping_cost DECIMAL(10, 2) NOT NULL,
  discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0,
  stripe_payment_intent_id TEXT,
  billing_address_id UUID NOT NULL REFERENCES addresses(id),
  shipping_address_id UUID NOT NULL REFERENCES addresses(id),
  shipping_method TEXT NOT NULL,
  tracking_number TEXT,
  notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Order items table
CREATE TABLE order_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES products(id),
  quantity INTEGER NOT NULL,
  unit_price DECIMAL(10, 2) NOT NULL,
  total_price DECIMAL(10, 2) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Function to increment inventory quantity
CREATE OR REPLACE FUNCTION increment_inventory(p_product_id UUID, p_quantity INTEGER)
RETURNS VOID AS $$
BEGIN
  UPDATE products
  SET inventory_quantity = inventory_quantity + p_quantity,
      updated_at = now()
  WHERE id = p_product_id;
END;
$$ LANGUAGE plpgsql;

-- RLS (Row Level Security) Policies

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE addresses ENABLE ROW LEVEL SECURITY;
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_images ENABLE ROW LEVEL SECURITY;
ALTER TABLE carts ENABLE ROW LEVEL SECURITY;
ALTER TABLE cart_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE order_items ENABLE ROW LEVEL SECURITY;

-- Users table policies
CREATE POLICY "Users can view their own profile" ON users
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile" ON users
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Admin can view all users" ON users
  FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- Addresses table policies
CREATE POLICY "Users can CRUD their own addresses" ON addresses
  USING (auth.uid() = user_id);

CREATE POLICY "Admin can view all addresses" ON addresses
  FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- Categories table policies
CREATE POLICY "Categories are publicly viewable" ON categories
  FOR SELECT USING (true);

CREATE POLICY "Admin can manage categories" ON categories
  USING (auth.jwt() ->> 'role' = 'admin');

-- Products table policies
CREATE POLICY "Active products are publicly viewable" ON products
  FOR SELECT USING (is_active = true);

CREATE POLICY "Admin can manage products" ON products
  USING (auth.jwt() ->> 'role' = 'admin');

-- Product images table policies
CREATE POLICY "Product images are publicly viewable" ON product_images
  FOR SELECT USING (true);

CREATE POLICY "Admin can manage product images" ON product_images
  USING (auth.jwt() ->> 'role' = 'admin');

-- Carts table policies
CREATE POLICY "Users can manage their own carts" ON carts
  USING (
    auth.uid() = user_id OR 
    (user_id IS NULL AND session_id = current_setting('request.headers')::json->>'cart-session-id')
  );

CREATE POLICY "Admin can view all carts" ON carts
  FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- Cart items table policies
CREATE POLICY "Users can manage their own cart items" ON cart_items
  USING (
    EXISTS (
      SELECT 1 FROM carts
      WHERE carts.id = cart_id
      AND (
        carts.user_id = auth.uid() OR
        (carts.user_id IS NULL AND carts.session_id = current_setting('request.headers')::json->>'cart-session-id')
      )
    )
  );

CREATE POLICY "Admin can view all cart items" ON cart_items
  FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- Orders table policies
CREATE POLICY "Users can view their own orders" ON orders
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Admin can manage all orders" ON orders
  USING (auth.jwt() ->> 'role' = 'admin');

-- Order items table policies
CREATE POLICY "Users can view their own order items" ON order_items
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM orders
      WHERE orders.id = order_id
      AND orders.user_id = auth.uid()
    )
  );

CREATE POLICY "Admin can manage all order items" ON order_items
  USING (auth.jwt() ->> 'role' = 'admin');

-- Create indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_addresses_user_id ON addresses(user_id);
CREATE INDEX idx_products_category_id ON products(category_id);
CREATE INDEX idx_products_is_active ON products(is_active);
CREATE INDEX idx_product_images_product_id ON product_images(product_id);
CREATE INDEX idx_carts_user_id ON carts(user_id);
CREATE INDEX idx_carts_session_id ON carts(session_id);
CREATE INDEX idx_cart_items_cart_id ON cart_items(cart_id);
CREATE INDEX idx_cart_items_product_id ON cart_items(product_id);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);
</file>

<file path="package.json">
{
  "name": "ecommerce-server",
  "version": "1.0.0",
  "description": "E-commerce platform",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "nodemon --exec ts-node -r tsconfig-paths/register src/server.ts",
    "lint": "eslint . --ext .ts",
    "test": "jest",
    "migrate": "ts-node src/db/migrations/run.ts"
  },
  "keywords": [
    "ecommerce",
    "express",
    "typescript",
    "supabase",
    "stripe"
  ],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@supabase/supabase-js": "^2.49.1",
    "bcrypt": "^5.1.1",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "csurf": "^1.10.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-validator": "^7.2.1",
    "helmet": "^8.0.0",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "stripe": "^17.7.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cookie-parser": "^1.4.8",
    "@types/cors": "^2.8.17",
    "@types/csurf": "^1.11.5",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^22.13.7",
    "nodemon": "^3.1.9",
    "supabase": "^2.15.8",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.8.2"
  }
}
</file>

<file path="postman-collection.json">
{
  "info": {
    "_postman_id": "b51d0e8f-76a6-4c4e-a4b7-94a41e2d5b8a",
    "name": "E-Commerce API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Health Check",
      "request": {
        "method": "GET",
        "url": {
          "raw": "{{base_url}}/health",
          "host": ["{{base_url}}"],
          "path": ["health"]
        }
      },
      "response": []
    },
    {
      "name": "Authentication",
      "item": [
        {
          "name": "Register",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"test@example.com\",\n  \"password\": \"Password123\",\n  \"first_name\": \"Test\",\n  \"last_name\": \"User\",\n  \"phone\": \"+1234567890\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/auth/register",
              "host": ["{{base_url}}"],
              "path": ["api", "auth", "register"]
            }
          },
          "response": []
        },
        {
          "name": "Login",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var jsonData = pm.response.json();",
                  "if (jsonData.data && jsonData.data.token) {",
                  "    pm.environment.set(\"token\", jsonData.data.token);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"test@example.com\",\n  \"password\": \"Password123\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/auth/login",
              "host": ["{{base_url}}"],
              "path": ["api", "auth", "login"]
            }
          },
          "response": []
        },
        {
          "name": "Forgot Password",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"test@example.com\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/auth/forgot-password",
              "host": ["{{base_url}}"],
              "path": ["api", "auth", "forgot-password"]
            }
          },
          "response": []
        },
        {
          "name": "Get Current User",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/auth/me",
              "host": ["{{base_url}}"],
              "path": ["api", "auth", "me"]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Products",
      "item": [
        {
          "name": "Get All Products",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/products?page=1&limit=10",
              "host": ["{{base_url}}"],
              "path": ["api", "products"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                },
                {
                  "key": "sort_by",
                  "value": "created_at",
                  "disabled": true
                },
                {
                  "key": "sort_order",
                  "value": "desc",
                  "disabled": true
                },
                {
                  "key": "query",
                  "value": "search term",
                  "disabled": true
                },
                {
                  "key": "category_id",
                  "value": "some-uuid",
                  "disabled": true
                },
                {
                  "key": "min_price",
                  "value": "10",
                  "disabled": true
                },
                {
                  "key": "max_price",
                  "value": "100",
                  "disabled": true
                },
                {
                  "key": "in_stock",
                  "value": "true",
                  "disabled": true
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Get Product By ID",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/products/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "products", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "product-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Create Product (Admin)",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Japanese Bath Salts\",\n  \"description\": \"Authentic bath salts from Japan\",\n  \"price\": 14.99,\n  \"compare_at_price\": 19.99,\n  \"cost_price\": 7.50,\n  \"sku\": \"JBS-001\",\n  \"barcode\": \"123456789\",\n  \"weight\": 250,\n  \"dimensions\": {\n    \"length\": 10,\n    \"width\": 5,\n    \"height\": 2\n  },\n  \"inventory_quantity\": 100,\n  \"is_active\": true,\n  \"category_id\": \"category-id-here\",\n  \"images\": [\n    {\n      \"url\": \"https://example.com/image1.jpg\",\n      \"alt_text\": \"Japanese Bath Salts Front\",\n      \"position\": 1,\n      \"is_primary\": true\n    }\n  ]\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/products",
              "host": ["{{base_url}}"],
              "path": ["api", "products"]
            }
          },
          "response": []
        },
        {
          "name": "Update Product (Admin)",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Premium Japanese Bath Salts\",\n  \"price\": 16.99,\n  \"inventory_quantity\": 95\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/products/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "products", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "product-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Delete Product (Admin)",
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/products/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "products", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "product-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Get Categories",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/products/categories",
              "host": ["{{base_url}}"],
              "path": ["api", "products", "categories"]
            }
          },
          "response": []
        },
        {
          "name": "Get Category By ID",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/products/categories/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "products", "categories", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "category-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Get Products By Category",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/products/categories/:id/products",
              "host": ["{{base_url}}"],
              "path": ["api", "products", "categories", ":id", "products"],
              "variable": [
                {
                  "key": "id",
                  "value": "category-id-here"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Cart",
      "item": [
        {
          "name": "Get Cart",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text",
                "disabled": true
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/cart",
              "host": ["{{base_url}}"],
              "path": ["api", "cart"]
            },
            "description": "Get cart for authenticated user or guest (based on cookie)"
          },
          "response": []
        },
        {
          "name": "Add Item to Cart",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text",
                "disabled": true
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"product_id\": \"product-id-here\",\n  \"quantity\": 2\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/cart/items",
              "host": ["{{base_url}}"],
              "path": ["api", "cart", "items"]
            }
          },
          "response": []
        },
        {
          "name": "Update Cart Item",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text",
                "disabled": true
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"quantity\": 3\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/cart/items/:itemId",
              "host": ["{{base_url}}"],
              "path": ["api", "cart", "items", ":itemId"],
              "variable": [
                {
                  "key": "itemId",
                  "value": "cart-item-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Remove Cart Item",
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text",
                "disabled": true
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/cart/items/:itemId",
              "host": ["{{base_url}}"],
              "path": ["api", "cart", "items", ":itemId"],
              "variable": [
                {
                  "key": "itemId",
                  "value": "cart-item-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Clear Cart",
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text",
                "disabled": true
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/cart",
              "host": ["{{base_url}}"],
              "path": ["api", "cart"]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Shipping",
      "item": [
        {
          "name": "Calculate Shipping Rates",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"address_id\": \"address-id-here\",\n  \"cart_id\": \"cart-id-here\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/shipping/calculate",
              "host": ["{{base_url}}"],
              "path": ["api", "shipping", "calculate"]
            }
          },
          "response": []
        },
        {
          "name": "Validate Address",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"address_line1\": \"123 Main St\",\n  \"address_line2\": \"Apt 4B\",\n  \"city\": \"New York\",\n  \"state\": \"NY\",\n  \"postal_code\": \"10001\",\n  \"country\": \"US\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/shipping/validate-address",
              "host": ["{{base_url}}"],
              "path": ["api", "shipping", "validate-address"]
            }
          },
          "response": []
        },
        {
          "name": "Track Shipment",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/shipping/tracking/:trackingNumber",
              "host": ["{{base_url}}"],
              "path": ["api", "shipping", "tracking", ":trackingNumber"],
              "variable": [
                {
                  "key": "trackingNumber",
                  "value": "tracking-number-here"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Payment",
      "item": [
        {
          "name": "Create Payment Intent",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"cart_id\": \"cart-id-here\",\n  \"shipping_address_id\": \"address-id-here\",\n  \"billing_address_id\": \"address-id-here\",\n  \"shipping_method\": \"standard\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/payment/create-payment-intent",
              "host": ["{{base_url}}"],
              "path": ["api", "payment", "create-payment-intent"]
            }
          },
          "response": []
        },
        {
          "name": "Check Payment Status",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/payment/payment-status/:paymentIntentId",
              "host": ["{{base_url}}"],
              "path": ["api", "payment", "payment-status", ":paymentIntentId"],
              "variable": [
                {
                  "key": "paymentIntentId",
                  "value": "payment-intent-id-here"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Orders",
      "item": [
        {
          "name": "Get My Orders",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/orders/my-orders",
              "host": ["{{base_url}}"],
              "path": ["api", "orders", "my-orders"]
            }
          },
          "response": []
        },
        {
          "name": "Get Order Details",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/orders/my-orders/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "orders", "my-orders", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "order-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Cancel Order",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/orders/my-orders/:id/cancel",
              "host": ["{{base_url}}"],
              "path": ["api", "orders", "my-orders", ":id", "cancel"],
              "variable": [
                {
                  "key": "id",
                  "value": "order-id-here"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "User",
      "item": [
        {
          "name": "Get Profile",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/users/me",
              "host": ["{{base_url}}"],
              "path": ["api", "users", "me"]
            }
          },
          "response": []
        },
        {
          "name": "Update Profile",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"first_name\": \"Updated\",\n  \"last_name\": \"Name\",\n  \"phone\": \"+1987654321\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/users/me",
              "host": ["{{base_url}}"],
              "path": ["api", "users", "me"]
            }
          },
          "response": []
        },
        {
          "name": "Get Addresses",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/users/me/addresses",
              "host": ["{{base_url}}"],
              "path": ["api", "users", "me", "addresses"]
            }
          },
          "response": []
        },
        {
          "name": "Add Address",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Home\",\n  \"address_line1\": \"123 Main St\",\n  \"address_line2\": \"Apt 4B\",\n  \"city\": \"New York\",\n  \"state\": \"NY\",\n  \"postal_code\": \"10001\",\n  \"country\": \"US\",\n  \"is_default\": true\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/users/me/addresses",
              "host": ["{{base_url}}"],
              "path": ["api", "users", "me", "addresses"]
            }
          },
          "response": []
        },
        {
          "name": "Update Address",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Updated Home\",\n  \"address_line1\": \"456 Main St\",\n  \"city\": \"Brooklyn\",\n  \"state\": \"NY\",\n  \"postal_code\": \"11201\",\n  \"country\": \"US\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/users/me/addresses/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "users", "me", "addresses", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "address-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Delete Address",
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/users/me/addresses/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "users", "me", "addresses", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "address-id-here"
                }
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "Admin",
      "item": [
        {
          "name": "Get All Users",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/admin/users",
              "host": ["{{base_url}}"],
              "path": ["api", "admin", "users"]
            }
          },
          "response": []
        },
        {
          "name": "Get User Details",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/admin/users/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "admin", "users", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "user-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Get All Orders",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/admin/orders",
              "host": ["{{base_url}}"],
              "path": ["api", "admin", "orders"]
            }
          },
          "response": []
        },
        {
          "name": "Get Order Details",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/admin/orders/:id",
              "host": ["{{base_url}}"],
              "path": ["api", "admin", "orders", ":id"],
              "variable": [
                {
                  "key": "id",
                  "value": "order-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Update Order Status",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"shipped\",\n  \"tracking_number\": \"1Z9999999999999999\"\n}"
            },
            "url": {
              "raw": "{{base_url}}/api/admin/orders/:id/status",
              "host": ["{{base_url}}"],
              "path": ["api", "admin", "orders", ":id", "status"],
              "variable": [
                {
                  "key": "id",
                  "value": "order-id-here"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "Get Dashboard Stats",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{token}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{base_url}}/api/admin/dashboard",
              "host": ["{{base_url}}"],
              "path": ["api", "admin", "dashboard"]
            }
          },
          "response": []
        }
      ]
    }
  ]
}
</file>

<file path="readme.md">
# E-commerce Backend

A production-grade e-commerce backend for selling products. Built with Node.js, Express, TypeScript, Supabase, and Stripe integration.

## Features

- **User Authentication**: Registration, login, password recovery with Supabase Auth
- **Product Management**: Categories, products, images, inventory management
- **Shopping Cart**: Cart management with user and guest session support
- **Order Processing**: Comprehensive order management workflow
- **Payment Integration**: Secure checkout with Stripe
- **Shipping**: Shipping calculation, address validation, and tracking
- **User Management**: User profiles and address book
- **Admin Panel**: Admin-specific endpoints for managing products, orders, and users
- **Security**: Input validation, error handling, CORS, and JWT authentication

## Tech Stack

- **Language**: TypeScript
- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: PostgreSQL (via Supabase)
- **Authentication**: Supabase Auth
- **Payment Processing**: Stripe
- **Validation**: Express Validator & Joi
- **Error Handling**: Custom error classes and middleware
- **Logging**: Custom logger implementation

## Project Structure

```
 src/
    config/           # Configuration files
    controllers/      # Route controllers
    middlewares/      # Express middlewares
    models/           # Data models
    routes/           # API routes
    services/         # Business logic
    types/            # TypeScript type definitions
    utils/            # Utility functions
       validators/   # Input validation schemas
    app.ts            # Express app setup
    server.ts         # Server entry point
 dist/                 # Compiled JavaScript
 .env                  # Environment variables
 .env.example          # Example environment variables
 tsconfig.json         # TypeScript configuration
 package.json          # Dependencies
```

## API Endpoints

### Authentication

- `POST /api/auth/register` - Register new user
- `POST /api/auth/login` - User login
- `POST /api/auth/forgot-password` - Password reset request
- `POST /api/auth/reset-password` - Reset password with token
- `GET /api/auth/me` - Get current user profile

### Products

- `GET /api/products` - List all products (with pagination, filtering, sorting)
- `GET /api/products/search` - Search products
- `GET /api/products/:id` - Get product details
- `POST /api/products` - Create product (admin only)
- `PUT /api/products/:id` - Update product (admin only)
- `DELETE /api/products/:id` - Delete product (admin only)
- `GET /api/products/categories` - List all categories
- `GET /api/products/categories/:id` - Get category details
- `GET /api/products/categories/:id/products` - Get products by category

### User Management

- `GET /api/users/me` - Get current user profile
- `PUT /api/users/me` - Update current user profile
- `GET /api/users/me/addresses` - Get user addresses
- `POST /api/users/me/addresses` - Add new address
- `PUT /api/users/me/addresses/:id` - Update address
- `DELETE /api/users/me/addresses/:id` - Delete address

### Cart & Orders

- `GET /api/cart` - Get cart contents
- `POST /api/cart/items` - Add item to cart
- `PUT /api/cart/items/:id` - Update cart item
- `DELETE /api/cart/items/:id` - Remove item from cart
- `DELETE /api/cart` - Clear cart
- `GET /api/orders/my-orders` - List user orders
- `GET /api/orders/my-orders/:id` - Get order details
- `POST /api/orders/my-orders/:id/cancel` - Cancel order

### Shipping

- `POST /api/shipping/calculate` - Calculate shipping rates
- `POST /api/shipping/validate-address` - Validate shipping address
- `GET /api/shipping/tracking/:trackingNumber` - Get tracking information

### Payment

- `POST /api/payment/create-payment-intent` - Create payment intent
- `GET /api/payment/payment-status/:paymentIntentId` - Check payment status
- `POST /api/payment/webhook` - Handle Stripe webhook events

### Admin

- `GET /api/admin/dashboard` - Get dashboard statistics
- `GET /api/admin/orders` - List all orders
- `GET /api/admin/orders/:id` - Get order details
- `PUT /api/admin/orders/:id/status` - Update order status
- `GET /api/admin/users` - List all users
- `GET /api/admin/users/:id` - Get user details

## Getting Started

### Prerequisites

- Node.js (v16+)
- npm or yarn
- Supabase account
- Stripe account

### Installation

1. Clone the repository

   ```bash
   git clone https://github.com/yourusername/e-commerce-backend.git
   cd e-commerce-backend
   ```

2. Install dependencies

   ```bash
   npm install
   ```

3. Create a `.env` file based on `.env.example`

   ```bash
   cp .env.example .env
   ```

4. Set up your Supabase database

   - Create a new Supabase project
   - Run the database schema SQL from `supabase-schema.sql` in the Supabase SQL editor
   - Update your `.env` file with your Supabase credentials

5. Set up Stripe

   - Create a Stripe account
   - Get your API keys and update your `.env` file
   - Set up webhooks to point to your `/api/payment/webhook` endpoint

6. Build the project

   ```bash
   npm run build
   ```

7. Start the server

   ```bash
   npm start
   ```

   For development:

   ```bash
   npm run dev
   ```
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2022",
    "module": "commonjs",
    "lib": ["es2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "sourceMap": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

</files>
